谷粒学院

## 一、前后端分离

### 1. @RequestBody 注解的使用

```java
    /**
     * @RequestBody 注解：使用json传递数据，把json数据封装到对应的对象里
     * 一旦使用了 @RequestBody，注解，提交方式必须是post，否则获取不到数据
     * 且参数值可以为null
     * 一旦加了@RequestBody 注解，普通的通过表单方式提交数据就无效了，只能使用json提交
     */
    @ApiOperation("带条件的分页查询")
    @PostMapping("/paginationFindTeacherByCondition/{currentPage}/{size}")
    public Result paginationFindTeacherByCondition(@PathVariable Long currentPage, 
                                                   @PathVariable Long size, 
                                                   @RequestBody(required = false) TeacherQuery teacherQuery) {
    }
```

```javascript
    /**
     * 封装多个参数到实体对象中，建议使用post方式，因为get方式在spring boot封装成对象的时候会报错
     * 通过选项传递参数（默认传递的是json的数据，需要后端提供支持，后端添加注解 @RequestBody(required = true) ）
     * */
    function PostJson() {
        axios.post("http://127.0.0.1:8001/edu/teacher/addTeacher", {
            name: "高老师",
            intro: "高老师很不错",
            level: 1
        })
            .then(resp => {
                // 通过 .data 获取真正的数据
                console.log(resp.data);
            })
    }
```




![Snip20200808_1](/Users/luo/Documents/开发笔记/images/Snip20200808_1.png)

### 2. Mybatis-plus 自动插入/更新时间

（1）实体属性添加注解

```java
@TableName("edu_teacher")
public class Teacher implements Serializable {    
		/**
     * 插入的时候自动插入时间
     * */
    @TableField(fill = FieldFill.INSERT)
    @ApiModelProperty(value = "创建时间")
    private Date gmtCreate;

    /**
     * 更新的时候自动更新时间
     * */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    @ApiModelProperty(value = "更新时间")
    private Date gmtModified;
}
```

（2）创建 MetaObjectHandler 实现类

```java
package com.guli.serviceBase.handler.mybatisPlus;
/*
 * @Author 罗
 * @date 2020/8/8 - 6:38 下午
 */

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;

import java.util.Date;

/**
 * 用于mybatis-plus插入时 自动插入日期、跟新时自动跟新日期
 * 注意传入的是属性名，不是字段名称
 * */
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        /**
         * 添加时，自动插入添加时间
         * */
        this.setFieldValByName("gmtCreate",new Date(),metaObject);
        /**
         * 添加时，自动插入更新时间
         * */
        this.setFieldValByName("gmtModified",new Date(),metaObject);

    }

    @Override
    public void updateFill(MetaObject metaObject) {
        /**
         * 更新时，自动更新更新时间
         * */
        this.setFieldValByName("gmtModified",new Date(),metaObject);
    }
}

```

（3）往容器中添加`MyMetaObjectHandler`对象

```java
    /**
     * 自动插入，自动更新字段组件
     * */
    @Bean
    public MetaObjectHandler metaObjectHandler(){
        return new MyMetaObjectHandler();
    }
```

（4）添加时不需要指定 两日期 gmtCreate gmtModified，id也不需要指定

![Snip20200808_3](/Users/luo/Documents/开发笔记/images/Snip20200808_3.png)

### 3. mybatis-plus 显示完整sql语句

（1）引入坐标

```xml
        <!--sql 分析打印插件-->
        <dependency>
            <groupId>p6spy</groupId>
            <artifactId>p6spy</artifactId>
            <version>3.8.2</version>
        </dependency>
```



（2）创建`resources/spy.properties`文件，写入以下内容

```properties

module.log=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory
# 自定义日志打印
logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger


#日志输出到控制台，解开注释就行了
appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger

# 指定输出文件位置
logfile=sql.log

# 使用日志系统记录 sql
#appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 设置 p6spy driver 代理
deregisterdrivers=true
# 取消JDBC URL前缀
useprefix=true
# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.
excludecategories=info,debug,result,batch,resultset
# 日期格式
dateformat=yyyy-MM-dd HH:mm:ss
# 实际驱动可多个
#driverlist=org.h2.Driver
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准 2 秒

```

（3）修改application.yml

```yml
spring:
  datasource:
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
    url: jdbc:p6spy:mysql://127.0.0.1:3306/home?useUnicode=true&characterEncoding=utf-8
```

### 4. 抛出自定义异常到前端

（1）异常类

```java
/**
 * 自定义异常类
 * */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomizedException extends RuntimeException {

    private Integer code;

    private String errorMessage;


}
```

（2）异常处理机

```java
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {    
		@ExceptionHandler(CustomizedException.class)
    @ResponseBody
    public Result customizedExceptionHandler(CustomizedException e){
        e.printStackTrace();
        log.info("出现自定义异常");

        return Result.error().code(e.getCode()).message(e.getErrorMessage());
    }
}
```

（3）手动抛出异常

```java
        try {

            int a = 10 / 0;

        } catch (ArithmeticException e) {
            throw new CustomizedException(400, "发现了算数异常");
        }
```

### 5. vscode 前端插件

![Snip20200808_4](/Users/luo/Documents/开发笔记/images/Snip20200808_4.png)

### 6. 允许Chrome跨域访问

AJAX请求跨域

我们要做的第一步，就是创建一个文件夹，这个文件夹是用来保存关闭安全策略后的用户信息的，名字可以随意取，位置也可以随意放

```shell
luo@luodeMacBook-Pro ~ % open -n /Applications/Google\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Volumes/extend/temp/chrome
```

### 7. 使用js根据数组元素的id，在数组中找到该元素

```javascript
								/**
                 * 方法一：根据id找到该对象所在数组的索引下表
                 **/
                let index = this.books.findIndex(book => {
                    if (book.id == this.tempBook.id) {
                        return true;
                    }
                });

                /**
                 * 方法二：找到该对象，直接进行修改
                 * */
                this.books.some(book=>{
                    if(book.id == this.tempBook.id){
                        this.tempBook.name = book.name;
                      return true;
                    }
                });

                /**
                 * 方法三：使用vue的 api 直接找到在数组中的该对象，放到数组中并返回
                 * */
                let bookArray = this.books.filter(book => {
                    return this.tempBook.id == book.id;
                });
```



### 8. 自己写的快速排序

#### （1）使用comparator的快速排序

```java
public class QuickSort {

    public static <T> void sort(List<T> list, int left, int right, Comparator<T> comparator) {
        int leftIndex = left;
        int rightIndex = right;
        int middleIndex = (leftIndex + rightIndex) / 2;
        T middle = list.get(middleIndex);
        T temp;
        while (leftIndex < rightIndex) {

            while (comparator.compare(list.get(leftIndex), middle) < 0) {
                leftIndex++;
            }

            while (comparator.compare(list.get(rightIndex), middle) > 0) {
                rightIndex--;
            }

            if (rightIndex == leftIndex) {
                break;
            }

            temp = list.get(leftIndex);
            list.set(leftIndex, list.get(rightIndex));
            list.set(rightIndex, temp);

            if (comparator.compare(list.get(leftIndex), middle) == 0) {
                rightIndex--;
            }

            if (comparator.compare(list.get(rightIndex), middle) == 0) {
                leftIndex++;
            }


        }

        if (rightIndex == leftIndex) {
            leftIndex++;
            rightIndex--;
        }
        /**
         * 防止只有两个相同的元素，造成堆栈溢出异常
         * */
        /*if (leftIndex > rightIndex && (right - left == 1)) {
            return;
        }*/

        if (rightIndex > left) {
            sort(list,left , rightIndex, comparator);
        }

        if (right > leftIndex) {
            sort(list, leftIndex, right, comparator);
        }

    }
}
```

#### （2）排序实现了 comparable 接口的类

```java
    public static <T extends Comparable<T>> void sort(List<T> list, int left, int right) {
        int leftIndex = left;
        int rightIndex = right;

        T axis = list.get((leftIndex + rightIndex) / 2);

        T temp;

        while (leftIndex < rightIndex) {

            while (list.get(leftIndex).compareTo(axis) < 0) {
                leftIndex++;
            }

            while (list.get(rightIndex).compareTo(axis) > 0) {
                rightIndex--;
            }

            temp = list.get(leftIndex);
            list.set(leftIndex, list.get(rightIndex));
            list.set(rightIndex, temp);

            if (leftIndex == rightIndex) {
                break;
            }

            if (list.get(leftIndex).compareTo(axis) == 0) {
                rightIndex--;
            }

            if (list.get(rightIndex).compareTo(axis) == 0) {
                leftIndex++;
            }
        }

        if (leftIndex == rightIndex) {
            leftIndex++;
            rightIndex--;
        }
        if (rightIndex - left > 0) {
            sort(list, left, rightIndex);
        }

        if (right - leftIndex > 0) {
            sort(list, leftIndex, right);
        }

    }
```

```java
    // this.sort 比较大，则为正
		@Override
    public int compareTo(Chapter o) {
        return this.sort - o.getSort();
    }
```

### 9. controller 接收对象中的日期格式设置

给字段添加注解@DateTimeFormat

````java
@Data
public class CourseQueryWrapper {

    private String teacherId;

    private String subjectId;

    private String title;

    private BigDecimal lowestPrice;

    private BigDecimal highestPrice;

    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date modifiedStartDate;

    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date modifiedEndDate;
}
````

### 10. 快速将数组中的元素用某一字符拼接成字符串

```java
/**
  * 使用 org.apache.commons.lang.StringUtils 将字符串数组中的所有元素用,连接，并拼接成一个字符串
  * */
String join = StringUtils.join(videoByChapterId.iterator(), ",");
/*
	[aa,bb,cc] ----->  "aa,bb,cc"
*/
```

### 11. Mybatis plus page 分页失效时的解决办法

```java
public Page<Course> getHotCourses(Integer currentPage, Integer limit) {

        Page<Course> coursePage = new Page<>(currentPage, limit);

        /**
         * 这里不知道为什么 Page 对象不能实现分页，所以使用 QueryWrapper 的 last() 方法来将 limit 1,10 拼接在sql语句的最后，实现分页查询
         * */
        QueryWrapper<Course> courseQueryWrapper = new QueryWrapper<>();

        courseQueryWrapper.last("limit " + currentPage + "," + limit);

        Page<Course> page = this.page(coursePage,courseQueryWrapper);

        //Page<Course> page = this.baseMapper.selectPage(coursePage, new QueryWrapper<Course>());

        log.info("查询热门课程，currentPage=" + currentPage + "，limit=" + limit + "，page=" + coursePage);

        return page;
    }
```

### 12. redis java对象转json

```java
package com.atguigu.servicebase;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@EnableCaching
@Configuration
public class RedisConfig extends CachingConfigurerSupport {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setConnectionFactory(factory);
        //key序列化方式
        template.setKeySerializer(redisSerializer);
        //value序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        //value hashmap序列化
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        //解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        // 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}

```



## 二、nodeJs

安装node js 的时候就自动安装了npm

### 1. 运行js脚本

```shell
luo@luodeMacBook-Pro js % ls
test.js
# 运行js脚本
luo@luodeMacBook-Pro js % node test.js
```

### 2. 使用nodeJs搭建第一个服务器

```javascript
const http = require("http");
http.createServer(function (req,resp) {
    // 发送http头部
    // http 状态值：200:ok
    // 内容类型： text/plain
    resp.writeHead(200,{"Content-Type":"text/plain"});
    // 发送响应数据"Hello World"
    resp.end("Hello World");
}).listen(8888);

console.log("Server running at http//:127.0.0.1:8888");
```

### 3. npm项目初始化操作

```shell
luo@luodeMacBook-Pro npmDemo % pwd 
/Volumes/extend/webPage/nodeJs/npmDemo

# 初始化，可以添加 -y 参数，全部同意
luo@luodeMacBook-Pro npmDemo % npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (npmdemo) 
version: (1.0.0) 
description: 第一个npm包
entry point: (index.js) 
test command: 
git repository: 
keywords: 
author: 罗俊华
license: (ISC) 
About to write to /Volumes/extend/webPage/nodeJs/npmDemo/package.json:

{
  "name": "npmdemo",
  "version": "1.0.0",
  "description": "第一个npm包,
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "罗俊华",
  "license": "ISC"
}


Is this OK? (yes) yes
luo@luodeMacBook-Pro npmDemo %
```

执行初始化之后，会多出一个`package.json`文件，类似于`pom.xml`

```json
{
  "name": "npmdemo",
  "version": "1.0.0",
  "description": "\"第一个npm包\"",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "\"罗俊华\"",
  "license": "ISC"
}
```



### 4. npm 下载js依赖

#### （1）配置镜像源

```shell
luo@luodeMacBook-Pro js % npm config set registry https://registry.npm.taobao.org

# 查看npm配置信息
luo@luodeMacBook-Pro js % npm config list
```

#### （2）添加依赖

```shell
# 注意需要在已经使用 npm init 初始化之后的目录下才能安装
luo@luodeMacBook-Pro npmDemo % npm install vue
# 安装时指定版本
npm install vue@2.6.10
```

```json
{
  "name": "npmdemo",
  "version": "1.0.0",
  "description": "第一个npm包",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "罗俊华",
  "license": "ISC",
  // 此时发现多出了一个依赖
  "dependencies": {
    "vue": "^2.6.11"
  }
}
```

#### （3）只有`package.json`的情况下，下载依赖

```shell
# 转到 package.json 所在相同目录，执行
npm install
```
#### （4）在项目中安装插件

```shell
# devDependencies 节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖
# 使用 -D 参数将依赖添加到 devDependencies 节点
npm install --save-dev eslint

# 或者
npm install -D eslint
```

全局安装

```shell
# node.js 全局安装的npm包和工具的位置，用户目录/AppData/Roaming/npm/node_modules
# 一些命令行工具常使用全局安装的方式
npm install -g webpack
```

#### （5）其他命令

```shell
# 更新包，更新到最新版本
npm update 包名

# 全局更新
npm update -g 包名

# 卸载包
npm uninstall 包名
# 全局卸载
npm uninstall -g 包名

# 列举包可使用版本
luo@localhost vue-admin-template-master % npm view element-ui versions

# 以下代码会升级到特定版本
luo@localhost vue-admin-template-master % npm update element-ui@2.13.2
```

### 5. babel

`babel`是转码器，把es6代码转换成es5代码

#### （1）安装

```shell
#  可能要多安装几次
luo@luodeMacBook-Pro npmDemo % sudo npm install -g babel-cli
npm WARN deprecated chokidar@1.7.0: Chokidar 2 will break on node v14+. Upgrade to chokidar 3 with 15x less dependencies.
npm WARN deprecated core-js@2.6.11: core-js@<3 is no longer maintained and not recommended for usage due to the number of issues. Please, upgrade your dependencies to the actual version of core-js@3.
/usr/local/bin/babel-doctor -> /usr/local/lib/node_modules/babel-cli/bin/babel-doctor.js
/usr/local/bin/babel -> /usr/local/lib/node_modules/babel-cli/bin/babel.js
/usr/local/bin/babel-external-helpers -> /usr/local/lib/node_modules/babel-cli/bin/babel-external-helpers.js
/usr/local/bin/babel-node -> /usr/local/lib/node_modules/babel-cli/bin/babel-node.js
+ babel-cli@6.26.0
updated 1 package in 7.605s

# 查看安装是否成功
luo@luodeMacBook-Pro npmDemo % babel --version
6.26.0 (babel-core 6.26.3)
```

#### （2）转换为es5

##### 【1】随便写一段`Es6`代码

`Es6.js`

```javascript
class Es6{
    constructor(name,age) {
        this.name = name;
        this.age = age;
    }
    info(){
        console.log(this.name+"的年龄是"+this.age);
    }
}

class Son extends Es6{
    constructor(name,age) {
        super(name,age);
    }
    sing(){
        console.log(this.name+"爱唱歌");
    }
}

let yan = new Son("燕",18);
yan.info();
yan.sing();
```

##### 【2】创建babel的配置文件

`Babel`的配置文件的全名是`.babelrc`，存放在项目的根目录下，该文件用来设置转码规则和插件，其基本格式如下

```json
luo@luodeMacBook-Pro npmDemo % tail .babelrc
{
	"presets":["es2015"],
	"plugins":[]
}
```

##### 【3】安装转码器

在项目中安装

```shell
luo@luodeMacBook-Pro npmDemo % npm install --save-dev babel-preset-es2015
```

##### 【4】转码

```shell
# 将转码结果写入一个文件
mkdir target

# --out-file 或者 -o 参数指定输出文件
luo@luodeMacBook-Pro npmDemo % babel es6.js -o target/es5.js

# 将./js 文件夹内的所有文件转为 es5 ，并放到 ./target 目录中
luo@luodeMacBook-Pro npmDemo % babel ./js -d ./target 
js/es6.js -> target/es6.js

```

### 6. es5模块化

#### （1）写法一

`01.js`

```javascript
// 1.创建js方法
// 定义成员

const sum = (a, b) => {
    return parseInt(a) + parseInt(b);
};

const subtract = (a, b) => {
    return parseInt(a) - parseInt(b);
};

// 2.设置哪些方法可以被其他js调用（简写）
module.exports = {
    sum,
    subtract
}

// 完整写法
/*
module.exports = {
    sum:sum,
    subtract:subtract
}*/

```

`02.js`

```javascript
/**
 * 调用 01.js 里面的方法
 * 1.引入 01.js 文件，"./"不可以省略
 * */
const m = require("./01.js");

/**
 * 2.调用
 * */
let a = m.subtract(20,10);
let b= m.sum(100,200);

console.log(a,b)

```

运行`02.js`

```shell
luo@luodeMacBook-Pro Module_1 % node 02.js 
10 300

```

#### （2）写法二

```javascript
// 注意复数
exports.info = function(str){
  console.log(str,"第三种写法");
  document.write(str);
}
```



### 7. Es6 模块化

注意：**ES6的模块化无法在node.js 中运行，需要使用Babel转换为Es5后再执行**

记得安装`babel`，还有配置文件`.babelrc`

`es6.js`

```javascript
/**
 * 在es6语法中，类和方法前面直接加 export 就能对外暴露
 * */
export class Es6 {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    info() {
        console.log(this.name + "的年龄是" + this.age);
    }
}
/**
 * 对外暴露类
 * */
export class Son extends Es6 {
    constructor(name, age) {
        super(name, age);
    }

    sing() {
        console.log(this.name + "爱唱歌");
    }
}
/**
 * 对外暴露方法
 * */
export function sing(name,age) {
    let yan = new Son("燕", 18);
    yan.info();
    yan.sing();
}
```

`03.js`

```javascript
	import {sing,Son,Es6} from "./es6"
// 引入 es6.js 的时候 .js 可以省略
sing("燕",18);

let son = new Son("罗俊华",22);
son.info();

/**
 * 引入 es6.js 的类和方法进行调用
 * es5 的引入 和调用
 *
 * let m = require("./es6.js");
 * let luo = new m.Son("罗俊华",22);
 *
 * luo.info();
 *
 * m.sing("燕",18);
 * */
```

#### （1）转为ES5代码

```shell
babel ./module_es6 -d ./target_es5
```

#### （2）运行

```shell
luo@luodeMacBook-Pro moduleDemo % node ./target_es5/03.js       
燕的年龄是18
燕爱唱歌
罗俊华的年龄是22

```

#### （3）写法二

`es6_2.js`

```javascript
export default {
    /**
     * 对外暴露方法
     * 省略export function
     * */
    sing(name, age) {
        console.log(name+"的年龄是"+age);
    },
    info(name){
        console.log(name+"的信息");
    }
}
```

`04.js`

```javascript
import m from "./es6_2"
// 使用 m 代替 es6_2.js

m.info("罗俊华");
m.sing("燕",18);
```



```shell
# 转为 es5 
luo@luodeMacBook-Pro moduleDemo % babel module_es6_2 -d target_es5 
# 运行
luo@luodeMacBook-Pro moduleDemo % node target_es5/04.js 
罗俊华的信息
燕的年龄是18

```

#### 

### 8. webpack

`webpack`是一个前端资源加载/打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

`webpack`可以将多种静态资源 js,css,less 转为一个静态文件，减少了页面的请求

![Snip20200812_2](/Users/luo/Documents/开发笔记/images/Snip20200812_2.png)

#### （1）全局安装webpack

```shell
luo@luodeMacBook-Pro webpack % sudo npm install -g webpack webpack-cli

# 查看版本号
webpack -v
```

#### （2）使用

`common.js`

```javascript
exports.info = function (str) {
    console.log("接收到",str);
    document.write(str); // 只有浏览器才能使用document，nodejs运行不了
}
```

`util.js`

```javascript
exports.add = function (a,b) {
    return parseInt(a) + parseInt(b);
}
```

`main.js`

```javascript
import c from "./common"
import u from "./util"

c.info("你好，"+u.add(10,20));
```

创建`webpack`配置文件`webpack.config.js`，配置打包信息

期间可以先使用`babel`转为es5，再使用`webpack`打包，注意：使用`babel`的时候，不会复制`css`文件，需要手动复制

```javascript
const path = require("path"); //Node.js 内置模块

module.exports = {
    entry: "./target/main.js", // 配置入口文件
    output: {
        // _dirname：当前文件所在路径（固定，无需更改 ）
        // path: path.resolve(_dirname, "./out"), 中的 _dirname 会报异常，直接使用地址写死的方式
        // ./out: 输出路径
        path: path.resolve("/Volumes/extend/webPage/nodeJs/webpack", "./out"),
        filename: "bundle.js"    // 输出文件
    }
}
```

执行打包

```shell
# 打包后为一行，不是给人看的
webpack

# 没有警告 --mode=development，打包后有注释，比较好看
webpack --mode=development
```

（可选）要想没有警告，也可以修改 `package.json`文件

```json
{
	// 省略
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1", // 原有
    "dev": "webpack --mode=development"		// 新增
  },
	// 省略
}
```

（可选）然后使用npm命令来打包

```shell
npm run dev
```



Html 引入打包好的`bundle.js`查看效果

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script src="./bundle.js" type="text/javascript"></script>
</body>
</html>
```

#### （3）安装 style-loader 和 css-loader

webpack 本身只能处理 `js` 模块，如果要处理其他类型的文件，就需要使用`loader`进行转换。

loader 可以理解为是模块和资源的转换器

【1】首先我们需要安装loader 插件，`css-loader`是将`css`装载到`js`；`style-loader`是让`js`认识`css`

```shell
luo@luodeMacBook-Pro webpack % npm install --save-dev style-loader css-loader
```

【2】在入口js文件中引入`css`文件

```javascript
import c from "./common"
import u from "./util"
// 引入 css 文件时，扩展名不可以省略
import style from "./style.css"

c.info("你好，"+u.add(10,20));
```

【3】修改webpack的配置文件

```javascript
const path = require("path"); //Node.js 内置模块

module.exports = {
    entry: "./target/main.js", // 配置入口文件
    output: {
        // _dirname：当前文件所在路径（固定，无需更改 ）
        // path: path.resolve(_dirname, "./out"), 中的 _dirname 会报异常，直接使用地址写死的方式
        // ./out: 输出路径
        path: path.resolve("/Volumes/extend/webPage/nodeJs/webpack", "./out"),
        filename: "bundle.js"    // 输出文件
    },
    /**
     * 引入css模块
     * */
    module:{
        rules:[
            {
                test: /\.css$/,     // 打包规则应用到以css结尾的文件上
                use: ['style-loader','css-loader']
            }
        ]
    }
}
```

【4】打包

```shell
luo@luodeMacBook-Pro webpack % webpack --mode=development
# 打包之后，css文件也被集成进js文件了
```



## 三、搭建前端页面环境

选取一个模版（框架）进行环境搭建

`vue-admin-template` https://github.com/PanJiaChen/vue-admin-template

```shell
# 克隆镜像
luo@luodeMacBook-Pro vue-admin-template % git pull https://github.com/PanJiaChen/vue-admin-template.git

# 下载依赖，使用webstorm的自动下载可能会有问题，手动输入命令
npm install

# 运行
npm run dev
```

### 1. 前端框架入口

![Snip20200813_4](/Users/luo/Documents/开发笔记/images/Snip20200813_4.png)



### 2. 所用技术

使用框架（模版）搭建前端页面，主要基于两种技术

* vue
* Element-ui

### 3. 目录介绍

![Snip20200813_2](/Users/luo/Documents/开发笔记/images/Snip20200813_2.png)

* build：放项目构建脚本文件

* config：项目的基本配置

  ![Snip20200813_5](/Users/luo/Documents/开发笔记/images/Snip20200813_5.png)

  修改该目录下`index.js`

  ```javascript
   // 改为false    
  useEslint: false,
  // 可以帮助我们自动整理代码格式
  ```

  `dev.env.js`和`prod.env.js`开发环境配置文件

  ```javascript
  'use strict'
  const merge = require('webpack-merge')
  const prodEnv = require('./prod.env')
  
  module.exports = merge(prodEnv, {
    NODE_ENV: '"development"',
    // 要访问的接口地址
    BASE_API: '"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin"',
  })
  ```

  

* Src 目录

![Snip20200813_1](/Users/luo/Documents/开发笔记/images/Snip20200813_1.png)

### 4. 修改项目

（1）修改`config/dev.env.js`中的`BASE_API`

```javascript
'use strict'
const merge = require('webpack-merge')
const prodEnv = require('./prod.env')

module.exports = merge(prodEnv, {
  NODE_ENV: '"development"',
  //BASE_API: '"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin"',
  // 注意不是https
  BASE_API: '"http://localhost:8001/vue-admin"',
})
```

（2）进行登陆调用两个方法，login登陆操作的方法，和info登陆之后获取到用户信息的方法

`src/api/login.js`

所以，创建两个方法实现接口进行登陆

```javascript
import request from '@/utils/request'

export function login(username, password) {
  return request({
    url: '/user/login',
    method: 'post',
    data: {
      username,
      password
    }
  })
}

export function getInfo(token) {
  return request({
    url: '/user/info',
    method: 'get',
    params: { token }
  })
}
```

（3）`src/store/modules/user.js`定义了返回的有哪些数据

```javascript
		// 登录
    Login({ commit }, userInfo) {
      const username = userInfo.username.trim()
      return new Promise((resolve, reject) => {
        login(username, userInfo.password).then(response => {
          const data = response.data
          setToken(data.token)						// 登陆方法需要返回 token
          commit('SET_TOKEN', data.token)
          resolve()
        }).catch(error => {
          reject(error)
        })
      })
    },    

		// 获取用户信息
    GetInfo({ commit, state }) {
      return new Promise((resolve, reject) => {
        getInfo(state.token).then(response => {
          const data = response.data
          if (data.roles && data.roles.length > 0) { // 验证返回的roles是否是一个非空数组
            commit('SET_ROLES', data.roles) 				// 角色
          } else {
            reject('getInfo: roles must be a non-null array !')
          }
          commit('SET_NAME', data.name)							// 名字
          commit('SET_AVATAR', data.avatar)					// 头像
          resolve(response)
        }).catch(error => {
          reject(error)
        })
      })
    },
```

`/user/login`需要返回`token`

`/user/info`需要返回`roles`,`name`,`avatar`

（4）`src/utils/request.js`中有说明返回正确的状态码是`20000`

```javascript
// response 拦截器
service.interceptors.response.use(
  response => {
    /**
     * code为非20000是抛错 可结合自己业务进行修改
     */
    const res = response.data
    if (res.code !== 20000) {
      Message({
        message: res.message,
        type: 'error',
        duration: 5 * 1000
      })
```



### 5. 跨域问题

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对`javascript`施加的安全限制

https://developer.mozilla.org/zh-CN/docs/web/http/access_control_cors

通过一个地址去访问另外一个地址，这个过程中如果有三个地方中的任何一个不一样就会出现跨域问题

* 访问协议
* ip地址
* 端口号

```
Access to XMLHttpRequest at 'http://localhost:8001/edu-teacher-service/user/login' from origin 'http://localhost:9528' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

#### （1）常用解决方式

在后端`controller`添加注解

```java
@RestController
@Slf4j
@RequestMapping("/edu-teacher-service/user")
@CrossOrigin
public class EduLoginController {
```

#### （2）使用 gateway 解决

#### （3）请求重复

![Snip20200813_3](/Users/luo/Documents/开发笔记/images/Snip20200813_3.png)

这里的`OPTIONS`请求是对该url的预处理，用于检测接口是否连接正常，预请求连接成功之后才发送真正的请求

#### （4）将所有应用都通过nginx代理

![Snip20200912_1](/Users/luo/Documents/开发笔记/images/Snip20200912_1.png)

#### （5）配置当次请求允许跨域

![Snip20200912_2](/Users/luo/Documents/开发笔记/images/Snip20200912_2.png)

### 6. 框架使用过程

#### （1）添加路由

从 `src/main.js`可以看出

```javascript
// 导入 src/router/ 目录下的所有js文件
import router from './router'

new Vue({
  el: '#app',
  router,
  store,
  render: h => h(App)
})
```

在 `src/router/index.js`中添加路由

```javascript
// 路由中引用了视图层模版
import Layout from '../views/layout/Layout'

export const constantRouterMap = [
  { path: '/login', component: () => import('@/views/login/index'), hidden: true },
  { path: '/404', component: () => import('@/views/404'), hidden: true },

  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    name: 'Dashboard',
    hidden: true,
    children: [{
      path: 'dashboard',
      component: () => import('@/views/dashboard/index')  //路由的子组件引用了另外的视图层模版
    }]
  },
```

#### （2）在views创建vue页面

视图层页面`src/views/dashboard/index.vue`

```html
<template>
  <div class="dashboard-container">
    <div class="dashboard-text">name:{{ name }}</div>
    <div class="dashboard-text">roles:<span v-for="role in roles" :key="role">{{ role }}</span></div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'

export default {
  name: 'Dashboard',
  computed: {
    ...mapGetters([
      'name',
      'roles'
    ])
  }
}
</script>
```

点击某个路由，显示路由对应页面的内容

#### （3）定义接口和参数

`src/api/table.js`

```javascript
import request from '@/utils/request'

export function getList(params) {
  return request({
    url: '/table/list',
    method: 'get',
    params
  })
}
```

#### （4）将vue视图层引入js文件，调用方法实现功能

因为上面的`src/views/dashboard/index.vue`没有调用后端接口，所以拿`src/views/table/index.vue`举例

```html
<script>
  // 调用了请求后端接口
import { getList } from '@/api/table'
  
  export default {
  filters: {
  },
  data() {
  },
  created() {
  },
  methods: {
  }
}
</script>
```

最后使用`element-ui`显示数据内容

### 7. 第一个框架示例

#### （1）路由

`src/router/index.js`

```javascript
  /**
   * 讲师模块的路由
   * */
  {
    path: '/edu-teacher',
    component: Layout,
    redirect: '/edu-teacher/list',
    name: 'edu-teacher',
    meta: {title: '教师管理', icon: 'example'},
    children: [
      {
        path: '/edu-teacher/list',
        name: 'teacher-list',
        component: () => import('@/views/edu/teacher/teacherList'),
        meta: {title: '教师列表', icon: 'table'}
      },
      {
        path: '/edu-teacher/tree',
        name: 'add-teacher',
        component: () => import('@/views/edu/teacher/addTeacher'),
        meta: {title: '添加讲师', icon: 'tree'}
      }
    ]
  },
```

#### （2）后端接口

`src/api/teacher.js`

```javascript
import request from '@/utils/request'

export function getTeacherList(current, limit, teacherQuery) {
  console.log("参数",current,limit);
  return request({
    // 写法一
    //url: '/edu/teacher/paginationFindTeacherByCondition/'+current+"/"+limit,
    // 写法二
    url: `/edu/teacher/paginationFindTeacherByCondition/${current}/${limit}`,
    method: 'post',
    /**
     * 因为后端使用 @requestBody 注解
     * data 表示把对象转化为 json 进行传递到接口里面
     * */
    data:teacherQuery
    /**
     * 不使用data方式，就使用这个
     * */
    /*params: {
      name: teacherQuery && teacherQuery.name
    }*/
  })
}

```

#### （3）视图层

`src/views/edu/teacher/teacherList.vue`

```html
<template>
  <el-table
    :data="teacherList.records"
    style="width: 100%"
    :row-class-name="tableRowClassName">
    <el-table-column
      prop="gmtModified"
      label="最后一次更新日期"
      width="180">
    </el-table-column>
    <el-table-column
      prop="name"
      label="姓名"
      width="180">
    </el-table-column>
    <el-table-column
      prop="intro"
      label="简介">
    </el-table-column>
  </el-table>
</template>

<style>
  .el-table .warning-row {
    background: oldlace;
  }

  .el-table .success-row {
    background: #f0f9eb;
  }
</style>

<script>
  import {getTeacherList} from '@/api/teacher'
  /**
   * 因为在 src/main.js 中已经封装了 new Vue({})，所以这里不用写了
   * */
  export default {
    methods: {
      /**
       * elementUI 自带，不用管
       * */
      tableRowClassName({row, rowIndex}) {
        if (rowIndex === 1) {
          return 'warning-row';
        } else if (rowIndex === 3) {
          return 'success-row';
        }
        return '';
      },
      getTeacherListInvoke(){
        var that = this;
        getTeacherList(this.currentPage,this.limit).then(resp => {
          console.log("resp", resp);
          that.teacherList = resp.data.teacherList;
          console.log(that.teacherList);

        });
      }
    },

    mounted() {
      this.getTeacherListInvoke();
    },
    data() {
      return {
        teacherList: [],
        currentPage:1,  //当前是第几页
        total:0,        //总记录数
        limit:10         //每页记录数
      }
    }
  }
</script>
```

### 8. 阿里OSS对象存储

#### （1）创建bucket

![Snip20200814_1](/Users/luo/Documents/开发笔记/images/Snip20200814_1.png)

![Snip20200814_2](/Users/luo/Documents/开发笔记/images/Snip20200814_2.png)

#### （2）操作阿里云

java代码操作阿里云oss，实现上传文件到阿里云oss

#### （3）准备工作

创建操作阿里云oss许可证（阿里云颁发的id和密钥）

![Snip20200814_3](/Users/luo/Documents/开发笔记/images/Snip20200814_3.png)

![Snip20200814_4](/Users/luo/Documents/开发笔记/images/Snip20200814_4.png)

![Snip20200814_5](/Users/luo/Documents/开发笔记/images/Snip20200814_5.png)

![Snip20200814_6](/Users/luo/Documents/开发笔记/images/Snip20200814_6.png)

学习文档所在位置

![Snip20200814_7](/Users/luo/Documents/开发笔记/images/Snip20200814_7.png)

https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.800.22196d39JwGDwJ

![Snip20200814_9](/Users/luo/Documents/开发笔记/images/Snip20200814_9.png)

### 9. nginx

![Snip20200814_8](/Users/luo/Documents/开发笔记/images/Snip20200814_8.png)

![Snip20200814_11](/Users/luo/Documents/开发笔记/images/Snip20200814_11.png)

#### （1）配置nginx

```shell
luo@luodeMacBook-Pro ~ % docker create -p 8000:8000 -v /Volumes/extend/docker_public_file_mapping/guli-nginx/nginx.conf:/etc/nginx/nginx.conf --name nginx nginx

# 记得配置 nginx.conf
luo@luodeMacBook-Pro ~ % touch /Volumes/extend/docker_public_file_mapping/guli-nginx/nginx.conf

luo@luodeMacBook-Pro ~ % docker start nginx
```

#### （2）nginx.conf

```shell
    server {                                                                                                                                   
        listen       80;                                                                                                                       
        server_name  192.168.2.10;                                                                                                             
                                                                                                                                               
        #charset koi8-r;                                                                                                                       
                                                                                                                                               
        #access_log  logs/host.access.log  main;                                                                                               
                                                                                                                                               
        # ~ 代表正则                                                                                                                           
        # 讲师模块                                                                                                                             
        location ~ /edu/teacher {                                                                                                              
                                                                                                                                               
            proxy_pass http://192.168.2.1:8001;                                                                                                
        }                                                                                                                                      
                                                                                                                                               
        # 登陆模块                                                                                                                             
        location ~ /edu-teacher-service/user {                                                                                                 
                                                                                                                                               
            proxy_pass http://192.168.2.1:8001;                                                                                                
        }                                                                                                                                      
                                                                                                                                               
        # 阿里云Oss服务                                                                                                                        
       location ~ /oss-service {                                                                                                               
                                                                                                                                               
            proxy_pass http://192.168.2.1:8002;                                                                                                
        }                                                                                                                                      
    } 
```

#### （3）前台页面nginx

```shell
luo@luodeMBP ~ % docker create -p 7000:7000 -v /Volumes/extend/docker_public_file_mapping/guli_nginx_front_page/nginx.conf:/etc/nginx/nginx.conf --name nginx-front nginx
```



### 10. vue 添加其他 component

​    复制`ImageCropper`和`PanThumb`组件到这里

![Snip20200815_1](/Users/luo/Documents/开发笔记/images/Snip20200815_1.png)

视图层引用组件

```javascript
  /**
   * 1.引入组件
   * */
  import PanThumb from "@/components/PanThumb"
  import ImageCropper from "@/components/ImageCropper"


  export default {
    /**
     * 2. 声明组件
     * */
    // 方式一
    // components:[PanThumb,ImageCropper],

    // 方式二
    components: {
      "pan-thumb": PanThumb,
      "image-cropper": ImageCropper
    },
```

视图层模版

```html
      <!--

          文件的上传是不可以使用Ajax的，这里的本质上是使用form表单+ post 方式 + 二进制字节流数据上传

      -->
      <el-form-item label="讲师头像，上传方式二">

        <el-button size="small" type="primary" @click="openImageCropperAndRefresh">点击上传2</el-button>

        <!--        头像缩略图-->
        <pan-thumb :image="getFormAvatar(form)"></pan-thumb>
        <!-- field 属性 相当于 <input type="file" name="multipartFile"/> 中的name，这个属性同时也将作为文件名
             :key 只要唯一即可
             @close 当点击 关闭按钮时触发
        -->
        <image-cropper v-show="displayImageCropper" :width="300" :height="300" :key="randomKey"
                       :url="BASE_API+'/oss-service/uploadAvatar'"
                       field="multipartFile" @close="displayImageCropper = !displayImageCropper"
                       @crop-upload-success="cropUploadSuccess"></image-cropper>

      </el-form-item>
```

### 11. EasyExcel

#### （1）创建excel表格

#### （2）创建excel表格对应的实体类

### 12. 流程

![Snip20200816_1](/Users/luo/Documents/开发笔记/images/Snip20200816_1.png)

细节：

* 创建vo实体用于表单数据封装
* 把表单提交过来的数据添加到数据库
  * 想两张表添加数据（课程表、课程描述表）
* 把`所属讲师`和`所属分类`使用下拉列表显示
  * 课程分类做成二级联动效果

![Snip20200816_2](/Users/luo/Documents/开发笔记/images/Snip20200816_2.png)

![Snip20200816_3](/Users/luo/Documents/开发笔记/images/Snip20200816_3.png)

#### （1）用到的表

* Edu_course：课程表：存储课程的基本信息
* Edu_course_description：课程简介表：存储课程详细信息
* Edu_chapter：课程章节表
* Edu_video：课程小节表，存储章节里面的信息
* Edu_teacher：讲师表
* edu_subject：分类表

![Snip20200816_4](/Users/luo/Documents/开发笔记/images/Snip20200816_4.png)

### 13. vue 富文本编辑器

https://packy-tang.gitee.io/vue-tinymce/#/

存储富文本的数据库 数据类型建议使用 text，而不是varchar

#### （1）安装

```shell
npm install @packy-tang/vue-tinymce
```

#### （2）main.js 中全局引入，不一定非要在这里引入，用到时再引入就行了

```javascript
import tinymce from 'tinymce'
import VueTinymce from '@packy-tang/vue-tinymce'


//样式
import 'tinymce/skins/content/default/content.min.css'
import 'tinymce/skins/ui/oxide/skin.min.css'
import 'tinymce/skins/ui/oxide/content.min.css'

//主题
import 'tinymce/themes/silver'

//插件
import 'tinymce/plugins/link' //链接插件
import 'tinymce/plugins/image' //图片插件
import 'tinymce/plugins/media' //媒体插件
import 'tinymce/plugins/table' //表格插件
import 'tinymce/plugins/lists' //列表插件
import 'tinymce/plugins/quickbars' //快速栏插件
import 'tinymce/plugins/fullscreen' //全屏插件
//注：5.3.x版本需要额外引进图标，没有所有按钮就会显示not found

import 'tinymce/icons/default/icons'

//本地化
import './utils/tinymce/langs/zh_CN.js'

Vue.prototype.$tinymce = tinymce
Vue.use(VueTinymce)
```

#### （3）我实际使用

![Snip20200817_2](/Users/luo/Documents/开发笔记/images/Snip20200817_2.png)

```html
<!-- # src/App.vue -->
<template>
  <div id="app">
<!--    加lazy 会报错-->
    <vue-tinymce @change="$emit('updateContent',content)"
      v-model="content"
      :setting="setting" />
  </div>
</template>

<script>
  import Vue from 'vue'

  /**
   * 富文本编辑器
   * */
  import tinymce from 'tinymce'
  import VueTinymce from '@packy-tang/vue-tinymce'

  //样式
  import 'tinymce/skins/content/default/content.min.css'
  import 'tinymce/skins/ui/oxide/skin.min.css'
  import 'tinymce/skins/ui/oxide/content.min.css'

  //主题
  import 'tinymce/themes/silver'

  //插件
  import 'tinymce/plugins/link' //链接插件
  import 'tinymce/plugins/image' //图片插件
  import 'tinymce/plugins/media' //媒体插件
  import 'tinymce/plugins/table' //表格插件
  import 'tinymce/plugins/lists' //列表插件
  import 'tinymce/plugins/quickbars' //快速栏插件
  import 'tinymce/plugins/fullscreen' //全屏插件
  //注：5.3.x版本需要额外引进图标，没有所有按钮就会显示not found

  import 'tinymce/icons/default/icons'

  //本地化
  import '@/utils/tinymce/langs/zh_CN.js'


  Vue.prototype.$tinymce = tinymce
  Vue.use(VueTinymce);

  Vue.config.productionTip = false

  export default {
    name: 'tinymce-name',  // 与name无关
    props:["contentFromFather"],
    data(){
      return {
        content:'',
        setting: {
          menubar: false,
          toolbar: "undo redo | fullscreen | formatselect alignleft aligncenter alignright alignjustify | link unlink | numlist bullist | image media table | fontselect fontsizeselect forecolor backcolor | bold italic underline strikethrough | indent outdent | superscript subscript | removeformat |",
          toolbar_drawer: "sliding",
          quickbars_selection_toolbar: "removeformat | bold italic underline strikethrough | fontsizeselect forecolor backcolor",
          plugins: "link image media table lists fullscreen quickbars",
          language: 'zh_CN',
          height: 350
        }
      }
    },
    mounted() {
      this.content = this.contentFromFather;
      console.log("富文本编辑器接收父组件的info：",this.content);
    }
  }
</script>
```



#### （4）下载汉化

http://tinymce.ax-z.cn/general/localize-your-language.php

https://www.tiny.cloud/get-tiny/language-packages/

并放在 `src/utils/tinymce/langs`

![Snip20200817_1](/Users/luo/Documents/开发笔记/images/Snip20200817_1.png)

#### （5）引用

```html
<template> 
		<div>
      <vue-tinymce :contentFromFather="course.desc" @updateContent="updateDesc($event)"></vue-tinymce>
    </div>
</template> 
<script>

  import vueTinymce from '@/components/Tinymce/index';

  export default {
    components:{
      "vue-tinymce":vueTinymce
    },
</script>
```

### 14. 阿里视屏点播服务

如果视屏使用了`hls`转码加密，则必须有域名才能进行点播

#### （1）文档&SDK

##### 【1】服务端api

阿里云提供固定的地址，只需要调用这个固定的地址，向地址传递参数，实现功能

示例：

```
http://vod.cn-shanghai.aliyuncs.com/?Action=GetPlayInfo&VideoId=93ab850b4f*****b54b6e91d24d81d4&Format=JSON&<公共参数>
```

> 其中`http://vod.cn-shanghai.aliyuncs.com/`为固定的地址

[具体官方说明，请点击](https://help.aliyun.com/document_detail/56124.html?spm=a2c4g.11186623.6.721.809b276dhtzmtd)

使用`HttpClient`就可以调用api地址

##### 【2】服务端sdk

`sdk`对`api`方式进行封装，更方便使用

调用阿里云提供的类或者接口里面的方法实现视频功能

#### （2）配置maven安装sdk

```xml
<profiles>
  <profile>
    <id>aliyun-video</id>

    <activation>
      <jdk>1.8</jdk>
    </activation>

    <repositories>
      <repository>
        <id>sonatype-nexus-staging</id>
        <name>Sonatype Nexus Staging</name>
        <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
        <releases>
          <enabled>true</enabled>
        </releases>
        <snapshots>
          <enabled>true</enabled>
        </snapshots>
      </repository>
    </repositories>
  </profile>
</profiles>

<!-- 2.根据profile的id标签值激活指定的内容（激活才能生效） -->
<activeProfiles>
  <!-- <activeProfile>nexus-repo</activeProfile> -->
  <activeProfile>aliyun-video</activeProfile>
</activeProfiles>
```

添加依赖

```xml
  <dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>aliyun-java-sdk-core</artifactId>
    <version>4.5.1</version>
  </dependency>
  <dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>aliyun-java-sdk-vod</artifactId>
    <version>2.15.10</version>
  </dependency>
  <dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.2</version>
  </dependency> 
```

#### （3）初始化

#### （4）上传媒体

安装SDK

以 1.4.12 版本为例，步骤如下:

1.下载Java示例代码VODUploadDemo-java-1.4.12.zip开发包(包含示例代码和所需jar包）, 见[服务端上传SDK](https://help.aliyun.com/document_detail/51992.html?spm=a2c4g.11186623.2.34.489e3815chVdNv#section-m21-rvo-stk) ;

2.将解压后lib目录下的所有jar文件拷贝至您的项目中;

3.SDK依赖的jar包版本说明

注意：以下列举出部分依赖jar包的版本，您可直接在您的项目中添加maven依赖，也可以将VODUploadDemo-java-1.4.12.zip包中的所有jar包引入您的项目中使用。其中，aliyun-java-vod-upload-1.4.12.jar 还未正式开源，请您直接引入jar包至您的项目中使用。

```shell
# 手动安装上传SDK到本地maven仓库，其他jar包都开源了，除了 aliyun-java-vod-upload-1.4.12.jar
luo@luodeMacBook-Pro ~ % /Volumes/OS/javaEE/maven/apache-maven-3.6.3/bin/mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.12 -Dpackaging=jar -Dfile=/Volumes/OS/javaEE/jar/VODUploadDemo-java-1.4.12/lib/aliyun-java-vod-upload-1.4.12.jar
```

**Nginx 会限制上传文件的大小，但是浏览器显示的是跨域问题，需要设置nginx**

```shell
        # 阿里云vod服务
        location ~ /vod/ {

            # nginx 提示 413 Request Entity Too Large
            client_max_body_size 1024m; # 改为你需要的大小!正确配置参考：
            proxy_pass http://192.168.2.1:8003;
        }
```



#### （5）获取视频播放地址

因为上传的视频可以进行加密，加密之后，使用已有的视频播放地址不能进行视频播放，在数据库中不存储视频地址，而是存储`视频id`

`视频id`不仅可以得到`视频地址`而且还可以得到`视频凭证`

### 15. nuxt

#### （1）目录介绍

`.nuxt` 存放编译好的可执行文件

`assets`存放项目中使用到的静态资源（css js omg）

`components` 放置项目使用的相关组件

`layouts`

​		`default.vue`定义网页布局的方式

`middleware`放置相关的组件

`node_modules`存放依赖

`pages`存放视图层页面

`nuxt_config.js`核心配置文件

#### （2）通过nuxt构建guli项目

从`github`拉取镜像

```shell
luo@luodeMBP nuxt % pwd
/Volumes/extend/webPage/nuxt

luo@luodeMBP nuxt % git init

luo@luodeMBP nuxt % git clone https://github.com/nuxt/nuxt.js.git
```

构建guli项目

```shell
# 安装从github上拉取的nuxt
luo@luodeMacBook-Pro template % sudo npm install -g @vue/cli

# 最后一项为工程的名字
luo@luodeMBP nuxt.js % npx create-nuxt-app guli

luo@luodeMBP nuxt.js % cd guli   
luo@luodeMBP guli % npm run build
luo@luodeMBP guli % npm run start

```

#### （3）nuxt页面说明

![Snip20200826_1](/Users/luo/Documents/开发笔记/images/Snip20200826_1.png)

#### （4）安装插件

```shell
# 安装幻灯片插件
luo@luodeMBP guli % npm install vue-awesome-swiper
# 发现有警告
npm WARN vue-awesome-swiper@4.1.1 requires a peer of swiper@^5.2.0 but none is installed. You must install peer dependencies yourself.
#  大致意识是 需要swiper5.2.0版本作为依赖，那就再装个swiper

luo@luodeMBP guli % npm install swiper --save

```

在`plugin`文件夹下创建 `nuxt-swiper-plugin.js`文件，其内容如下

```javascript
import Vue from 'vue'
// require styles
// 没有这个文件 import 'swiper/dist/css/swiper.css'
// 找了一个替代文件
import css from 'swiper/swiper.scss'
import VueAwesomeSwiper from 'vue-awesome-swiper'
export default () => {
  Vue.use(VueAwesomeSwiper,{css})
}
```

修改`nuxt.config.js`

```javascript
  plugins: [
    '@/plugins/element-ui',
    { src: "~/plugins/nuxt-swiper-pluign.js", ssr: false } //添加插件

  ],
```

#### （5）nuxt 中的动态路由

`nuxt`的动态路由是以下划线开头的`vue`文件（例如：_id.vue）参数名为下划线后面的文件名

### 16. 登陆

#### （1）单一服务器模式

使用session对象实现，登陆成功之后，把用户数据放到session对象中

判断用户是否登陆，从session中获得数据，可以获取到登陆数据

#### （2）单点登录

##### 【1】方式一：session广播机制实现

session复制，占内存，费资源，数据冗余

##### 【2】方式二：cookie+redis

1. 在项目中的任何一个模块登录，登陆之后，把数据放入到两个地方
   1. redis：key：`生成唯一的随机值`(用户ip，用户id，等等)，value：存放用户数据
   2. cookie：把`redis`中生成的`key`放入`cookie`中
2. 浏览器访问项目中的任意模块，`request`中带有`cookie`进行发送，获取`cookie`的值，拿来做事情
   1. 把从`cookie`获取到的值，到`redis`中进行查询，根据`key`进行查询，如果查询到数据，就说明已经登陆

##### 【3】方式三：token实现

token：`token`（令牌）是按照一定规则生成的字符串，字符串可以包含用户信息

> 192.168.1.1#luojunhua#头像 -> base64编码 -> 加密

1. 在项目某个模块进行登陆，登陆之后按照规则生成字符串，把登陆之后用户的信息包含到字符串里
2. 把生成的字符串返回
   1. 可以通过`cookie`返回
   2. 可以通过地址栏返回
3. 再去访问项目的其他模块，每次访问在地址栏携带`生成的字符串`，在访问模块可以获取到地址栏字符串，根据字符串获取用户信息（解码），如果获取得到就是登陆

`token`令牌编码可以有n中方式，每个人想法不同，所以可以使用官方比较通用的规则`jwt`

Jwt 是一种规定好了的规则，使用`jwt`规则可以生成字符串，包含用户信息

![Snip20200828_2](/Users/luo/Documents/开发笔记/images/Snip20200828_2.png)	

###### 1. jwt 生成的字符串包含三部分

第一部分：Header（红色部分）是一个描述`jwt`元数据的`json`对象通常如下显示

```javascript
{
  alg:'HS256', // 签名所使用的算法默认为 HMAC SHA256 （简称HS256）
  typ:'JWT'		// 令牌类型jwt令牌统一写为JWT
}
// 最后使用Base64 URL算法将上述json对象转换为json对象保存
```

第二部分：Claims（有效荷载）是jwt的主体内容部分，也是一个json对象，包含需要传递的数据，jwt指定7个默认字段供选择

> Iss：发行人
>
> exp：到期时间
>
> sub：主题
>
> aud：用户
>
> nbf：在此之前不可用
>
> iat：发布时间
>
> jti：jwt id 用于标识该jwt

除了上述默认字段之外，我们还可以自定义私有字段

```javascript
{
  sub:'123456',
  name:'张三',
  admin:'true'  
}
```

> 注意：默认情况下jwt是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露
>
> json对象也使用base64算法转换为字符串保存

第三部分 签名hash（防伪标志）

签名hash部分是对上面两部分数据签名，通过制定的算法生成hash，以确保数据不会被篡改

首先，需要指定一个密码`secret`。该密码仅仅保存在服务器中，并不能向用户公开。然后，使用`第一部分 head`中指定的签名算法（默认是 HMAC SHA256 ）根据以下公式生成签名

> HMAC SHA256 ( base64UrlEncode( header ) + "." + base64UrlEncode( claims ), secret )

在计算出签名hash之后，`jwt header`,` claims 主体`和`签名哈希`的三个部分组合成一个字符串，每个部分使用"."分隔，就构成jwt对象

###### 2. 使用jwt

导入依赖

```xml
<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt
	jwt 单点登陆
 -->
<dependency>
  <groupId>io.jsonwebtoken</groupId>
  <artifactId>jjwt</artifactId>
  <version>${jjwt.version}</version>
</dependency>
```

工具类`jwtUtils`

```java
package com.atguigu.commonutils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;

/**
 * @author helen
 * @since 2019/10/16
 */
public class JwtUtils {

    public static final long EXPIRE = 1000 * 60 * 60 * 24;
    public static final String APP_SECRET = "ukc8BDbRigUDaY6pZFfWus2jZWLPHO";

    public static String getJwtToken(String id, String nickname){

        String JwtToken = Jwts.builder()
                .setHeaderParam("typ", "JWT")
                .setHeaderParam("alg", "HS256")
                .setSubject("guli-user")
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))
                .claim("id", id)
                .claim("nickname", nickname)
                .signWith(SignatureAlgorithm.HS256, APP_SECRET)
                .compact();

        return JwtToken;
    }

    /**
     * 判断token是否存在与有效
     * @param jwtToken
     * @return
     */
    public static boolean checkToken(String jwtToken) {
        if(StringUtils.isEmpty(jwtToken)) return false;
        try {
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 判断token是否存在与有效
     * @param request
     * @return
     */
    public static boolean checkToken(HttpServletRequest request) {
        try {
            String jwtToken = request.getHeader("token");
            if(StringUtils.isEmpty(jwtToken)) return false;
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 根据token获取会员id
     * @param request
     * @return
     */
    public static String getMemberIdByJwtToken(HttpServletRequest request) {
        String jwtToken = request.getHeader("token");
        if(StringUtils.isEmpty(jwtToken)) return "";
        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        Claims claims = claimsJws.getBody();
        return (String)claims.get("id");
    }
}

```

`MD5`

```java
package com.atguigu.commonutils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public final class MD5 {

    public static String encrypt(String strSrc) {
        try {
            char hexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                    '9', 'a', 'b', 'c', 'd', 'e', 'f' };
            byte[] bytes = strSrc.getBytes();
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(bytes);
            bytes = md.digest();
            int j = bytes.length;
            char[] chars = new char[j * 2];
            int k = 0;
            for (int i = 0; i < bytes.length; i++) {
                byte b = bytes[i];
                chars[k++] = hexChars[b >>> 4 & 0xf];
                chars[k++] = hexChars[b & 0xf];
            }
            return new String(chars);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            throw new RuntimeException("MD5加密出错！！+" + e);
        }
    }

    public static void main(String[] args) {
        System.out.println(MD5.encrypt("111111"));
    }

}

```

`RandomUtil`

```java
package com.atguigu.msmservice.util;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

/**
 * 获取随机数
 * 
 * @author qianyi
 *
 */
public class RandomUtil {

	private static final Random random = new Random();

	private static final DecimalFormat fourdf = new DecimalFormat("0000");

	private static final DecimalFormat sixdf = new DecimalFormat("000000");

	public static String getFourBitRandom() {
		return fourdf.format(random.nextInt(10000));
	}

	public static String getSixBitRandom() {
		return sixdf.format(random.nextInt(1000000));
	}

	/**
	 * 给定数组，抽取n个数据
	 * @param list
	 * @param n
	 * @return
	 */
	public static ArrayList getRandom(List list, int n) {

		Random random = new Random();

		HashMap<Object, Object> hashMap = new HashMap<Object, Object>();

		// 生成随机数字并存入HashMap
		for (int i = 0; i < list.size(); i++) {

			int number = random.nextInt(100) + 1;

			hashMap.put(number, i);
		}

		// 从HashMap导入数组
		Object[] robjs = hashMap.values().toArray();

		ArrayList r = new ArrayList();

		// 遍历数组并打印数据
		for (int i = 0; i < n; i++) {
			r.add(list.get((int) robjs[i]));
			System.out.print(list.get((int) robjs[i]) + "\t");
		}
		System.out.print("\n");
		return r;
	}
}

```

### 17. 阿里云短信服务

![Snip20200828_3](/Users/luo/Documents/开发笔记/images/Snip20200828_3.png)

#### （1）添加模版

![Snip20200828_5](/Users/luo/Documents/开发笔记/images/Snip20200828_5.png)

#### （2）申请签名管理

> 注意：申请失败，点击修改的时候，发现名称不可以修改，多刷新几次即可，网站的小bug

### 18. 前端微信登陆

[官方文档](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html)

![微信登陆过程](/Users/luo/Documents/开发笔记/images/微信登陆过程.png)



#### （1）使用 httpClient 发送请求

`httpClient`工具类

> 整个使用HttpClient发送的请求都可以方便的使用`RestTemplate` 来解决
>
> ```java
>         String resultOfStep2 = null;
>         /*try {
>             resultOfStep2 = HttpClientUtils.get(basicAccessTokenUrl);
>         } catch (Exception e) {
>             e.printStackTrace();
>         }*/
> 
>         // 可以直接使用 spring-cloud 封装好的 restTemplate 来发送httpClient请求，效果与使用原生的 HttpClientUtils工具类效果一致
>         resultOfStep2 = this.restTemplate.getForObject(basicAccessTokenUrl, String.class);
> ```
>
> 

```java
package com.guli.utils;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.Consts;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.config.RequestConfig.Builder;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicNameValuePair;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import java.io.IOException;
import java.net.SocketTimeoutException;
import java.security.GeneralSecurityException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 *  依赖的jar包有：commons-lang-2.6.jar、httpclient-4.3.2.jar、httpcore-4.3.1.jar、commons-io-2.4.jar
*              <!-- http 请求客户端 -->
*             <dependency>
*                 <groupId>org.apache.httpcomponents</groupId>
*                 <artifactId>httpclient</artifactId>
*                 <version>${httpclient.version}</version>
*             </dependency>
*
*             <!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore -->
*             <dependency>
*                 <groupId>org.apache.httpcomponents</groupId>
*                 <artifactId>httpcore</artifactId>
*                 <version>${httpcore.version}</version>
*             </dependency>
*
*             <!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
*             <dependency>
*                 <groupId>commons-io</groupId>
*                 <artifactId>commons-io</artifactId>
*                 <version>${commons-io.version}</version>
*             </dependency>
*
*             <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
*             <dependency>
*                 <groupId>org.apache.commons</groupId>
*                 <artifactId>commons-lang3</artifactId>
*                 <version>${commons-lang3.version}</version>
*             </dependency>
 * @author zhaoyb
 *
 */
public class HttpClientUtils {

	public static final int connTimeout=10000;
	public static final int readTimeout=10000;
	public static final String charset="UTF-8";
	private static HttpClient client = null;

	static {
		PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();
		cm.setMaxTotal(128);
		cm.setDefaultMaxPerRoute(128);
		client = HttpClients.custom().setConnectionManager(cm).build();
	}

	public static String postParameters(String url, String parameterStr) throws ConnectTimeoutException, SocketTimeoutException, Exception{
		return post(url,parameterStr,"application/x-www-form-urlencoded",charset,connTimeout,readTimeout);
	}

	public static String postParameters(String url, String parameterStr,String charset, Integer connTimeout, Integer readTimeout) throws ConnectTimeoutException, SocketTimeoutException, Exception{
		return post(url,parameterStr,"application/x-www-form-urlencoded",charset,connTimeout,readTimeout);
	}

	public static String postParameters(String url, Map<String, String> params) throws ConnectTimeoutException,
			SocketTimeoutException, Exception {
		return postForm(url, params, null, connTimeout, readTimeout);
	}

	public static String postParameters(String url, Map<String, String> params, Integer connTimeout,Integer readTimeout) throws ConnectTimeoutException,
			SocketTimeoutException, Exception {
		return postForm(url, params, null, connTimeout, readTimeout);
	}

	public static String get(String url) throws Exception {
		return get(url, charset, null, null);
	}

	public static String get(String url, String charset) throws Exception {
		return get(url, charset, connTimeout, readTimeout);
	}

	/**
	 * 发送一个 Post 请求, 使用指定的字符集编码.
	 *
	 * @param url
	 * @param body RequestBody
	 * @param mimeType 例如 application/xml "application/x-www-form-urlencoded" a=1&b=2&c=3
	 * @param charset 编码
	 * @param connTimeout 建立链接超时时间,毫秒.
	 * @param readTimeout 响应超时时间,毫秒.
	 * @return ResponseBody, 使用指定的字符集编码.
	 * @throws ConnectTimeoutException 建立链接超时异常
	 * @throws SocketTimeoutException  响应超时
	 * @throws Exception
	 */
	public static String post(String url, String body, String mimeType,String charset, Integer connTimeout, Integer readTimeout)
			throws ConnectTimeoutException, SocketTimeoutException, Exception {
		HttpClient client = null;
		HttpPost post = new HttpPost(url);
		String result = "";
		try {
			if (StringUtils.isNotBlank(body)) {
				HttpEntity entity = new StringEntity(body, ContentType.create(mimeType, charset));
				post.setEntity(entity);
			}
			// 设置参数
			Builder customReqConf = RequestConfig.custom();
			if (connTimeout != null) {
				customReqConf.setConnectTimeout(connTimeout);
			}
			if (readTimeout != null) {
				customReqConf.setSocketTimeout(readTimeout);
			}
			post.setConfig(customReqConf.build());

			HttpResponse res;
			if (url.startsWith("https")) {
				// 执行 Https 请求.
				client = createSSLInsecureClient();
				res = client.execute(post);
			} else {
				// 执行 Http 请求.
				client = HttpClientUtils.client;
				res = client.execute(post);
			}
			result = IOUtils.toString(res.getEntity().getContent(), charset);
		} finally {
			post.releaseConnection();
			if (url.startsWith("https") && client != null&& client instanceof CloseableHttpClient) {
				((CloseableHttpClient) client).close();
			}
		}
		return result;
	}


	/**
	 * 提交form表单
	 *
	 * @param url
	 * @param params
	 * @param connTimeout
	 * @param readTimeout
	 * @return
	 * @throws ConnectTimeoutException
	 * @throws SocketTimeoutException
	 * @throws Exception
	 */
	public static String postForm(String url, Map<String, String> params, Map<String, String> headers, Integer connTimeout,Integer readTimeout) throws ConnectTimeoutException,
			SocketTimeoutException, Exception {

		HttpClient client = null;
		HttpPost post = new HttpPost(url);
		try {
			if (params != null && !params.isEmpty()) {
				List<NameValuePair> formParams = new ArrayList<NameValuePair>();
				Set<Entry<String, String>> entrySet = params.entrySet();
				for (Entry<String, String> entry : entrySet) {
					formParams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
				}
				UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formParams, Consts.UTF_8);
				post.setEntity(entity);
			}

			if (headers != null && !headers.isEmpty()) {
				for (Entry<String, String> entry : headers.entrySet()) {
					post.addHeader(entry.getKey(), entry.getValue());
				}
			}
			// 设置参数
			Builder customReqConf = RequestConfig.custom();
			if (connTimeout != null) {
				customReqConf.setConnectTimeout(connTimeout);
			}
			if (readTimeout != null) {
				customReqConf.setSocketTimeout(readTimeout);
			}
			post.setConfig(customReqConf.build());
			HttpResponse res = null;
			if (url.startsWith("https")) {
				// 执行 Https 请求.
				client = createSSLInsecureClient();
				res = client.execute(post);
			} else {
				// 执行 Http 请求.
				client = HttpClientUtils.client;
				res = client.execute(post);
			}
			return IOUtils.toString(res.getEntity().getContent(), "UTF-8");
		} finally {
			post.releaseConnection();
			if (url.startsWith("https") && client != null
					&& client instanceof CloseableHttpClient) {
				((CloseableHttpClient) client).close();
			}
		}
	}




	/**
	 * 发送一个 GET 请求
	 *
	 * @param url
	 * @param charset
	 * @param connTimeout  建立链接超时时间,毫秒.
	 * @param readTimeout  响应超时时间,毫秒.
	 * @return
	 * @throws ConnectTimeoutException   建立链接超时
	 * @throws SocketTimeoutException   响应超时
	 * @throws Exception
	 */
	public static String get(String url, String charset, Integer connTimeout,Integer readTimeout)
			throws ConnectTimeoutException,SocketTimeoutException, Exception {

		HttpClient client = null;
		HttpGet get = new HttpGet(url);
		String result = "";
		try {
			// 设置参数
			Builder customReqConf = RequestConfig.custom();
			if (connTimeout != null) {
				customReqConf.setConnectTimeout(connTimeout);
			}
			if (readTimeout != null) {
				customReqConf.setSocketTimeout(readTimeout);
			}
			get.setConfig(customReqConf.build());

			HttpResponse res = null;

			if (url.startsWith("https")) {
				// 执行 Https 请求.
				client = createSSLInsecureClient();
				res = client.execute(get);
			} else {
				// 执行 Http 请求.
				client = HttpClientUtils.client;
				res = client.execute(get);
			}

			result = IOUtils.toString(res.getEntity().getContent(), charset);
		} finally {
			get.releaseConnection();
			if (url.startsWith("https") && client != null && client instanceof CloseableHttpClient) {
				((CloseableHttpClient) client).close();
			}
		}
		return result;
	}


	/**
	 * 从 response 里获取 charset
	 *
	 * @param ressponse
	 * @return
	 */
	@SuppressWarnings("unused")
	private static String getCharsetFromResponse(HttpResponse ressponse) {
		// Content-Type:text/html; charset=GBK
		if (ressponse.getEntity() != null  && ressponse.getEntity().getContentType() != null && ressponse.getEntity().getContentType().getValue() != null) {
			String contentType = ressponse.getEntity().getContentType().getValue();
			if (contentType.contains("charset=")) {
				return contentType.substring(contentType.indexOf("charset=") + 8);
			}
		}
		return null;
	}



	/**
	 * 创建 SSL连接
	 * @return
	 * @throws GeneralSecurityException
	 */
	private static CloseableHttpClient createSSLInsecureClient() throws GeneralSecurityException {
		try {
			SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {
				public boolean isTrusted(X509Certificate[] chain,String authType) throws CertificateException {
					return true;
				}
			}).build();

			SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext, new X509HostnameVerifier() {

				@Override
				public boolean verify(String arg0, SSLSession arg1) {
					return true;
				}

				@Override
				public void verify(String host, SSLSocket ssl)
						throws IOException {
				}

				@Override
				public void verify(String host, X509Certificate cert)
						throws SSLException {
				}

				@Override
				public void verify(String host, String[] cns,
								   String[] subjectAlts) throws SSLException {
				}

			});

			return HttpClients.custom().setSSLSocketFactory(sslsf).build();

		} catch (GeneralSecurityException e) {
			throw e;
		}
	}

	public static void main(String[] args) {
		try {
			String str= post("https://localhost:443/ssl/test.shtml","name=12&page=34","application/x-www-form-urlencoded", "UTF-8", 10000, 10000);
			//String str= get("https://localhost:443/ssl/test.shtml?name=12&page=34","GBK");
            /*Map<String,String> map = new HashMap<String,String>();
            map.put("name", "111");
            map.put("page", "222");
            String str= postForm("https://localhost:443/ssl/test.shtml",map,null, 10000, 10000);*/
			System.out.println(str);
		} catch (ConnectTimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SocketTimeoutException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```

#### （2）后端登陆成功后跳转前端，并将token放在路径变量中

> 注意：cookie无法实现跨域（跨域名/ip读取）

```java
    /**
     * 因为 cookie 不能跨域，所以使用路径来传递令牌
     */
    private String getJwtAndRedirect(UcenterMember member) {

        String jwtToken = JwtUtils.getJwtToken(member.getId(), member.getNickname());

        log.info("此次，" + member.getNickname() + "的token = " + jwtToken);
        return "redirect:http://localhost:3000?token=" + jwtToken;
    }
```



#### （3）前端从路径中获取token

![js 中 location方法](/Users/luo/Documents/开发笔记/images/js 中 location方法.png)

对象方法： 
 location.host = “1.11.111.11:8080”; 
 (得到 URL 中的主机名称和端口号)

location.port = “8080”; 
 (得到URL中端口号)

location.hostname = “1.11.111.11”； 
 (得到URL中的主机名称)

location.href = “http://1.11.111.11:8080/locationtest/locationtest.html?id=1234&name=abcd“; 
 (获取整个URL路径)

location.search= “?id=1234&name=abcd”; 
 (设置或返回从问号 (?) 开始的 URL（查询部分）)

location.pathname = “/locationtest/locationtest.html”; 
 (设置或返回URL 中的路径部分) 

location.protocol = “http:”; 
 (设置或返回URL路径的协议)

location.origin = “http://1.11.111.11:8080“; 
 (设置或返回URL中的协议名称及主机名称、端口号)

#### （4）使用vue获取导航栏参数

[导航完成后获取数据（点击查看官方文档）]([https://router.vuejs.org/zh/guide/advanced/data-fetching.html#%E5%AF%BC%E8%88%AA%E5%AE%8C%E6%88%90%E5%90%8E%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE](https://router.vuejs.org/zh/guide/advanced/data-fetching.html#导航完成后获取数据))

```javascript
    methods: {
      getUserInfoFromCookie() {
        this.userInfo = cookie.getJSON('userInfo');

        /**
         * 或者使用这种方式
         * let strUserInfo = cookie.get('userInfo');
         if(strUserInfo){
            this.userInfo = JSON.parse(strUserInfo);
          }
         */

        console.log("通过cookie已登陆的用户信息是", this.userInfo);

        /**
         * 没有使用cookie进行登陆，现在切换到微信登陆
         * */
        if (!this.userInfo) {
          // 从地址栏中取出token
          let token = this.$route.query.token;
          console.log("从地址栏中取出的token = ", token,this.$route);


          console.log("通过原生js取出参数，",token);
          /*if (token) {
            // 将 token放到 cookie 中，之后只要axios请求，就会得到该cookie
            cookie.set('userToken', token, {domain: 'localhost'});
            login.getUserInfoByToken();
          }*/
        }
      },
      exit() {
        this.userInfo = {};
        cookie.remove('userToken');
        cookie.remove('userInfo');
        console.log("已退出登陆");
        location.reload();
      }
    },
    created() {
      this.getUserInfoFromCookie();
    },
    mounted() {
      console.log("mounted之后，route = ",this.$route)
    },
      // 核心一定要添加监视器，否则，无论是 created() 还是 mounted() 中，执行的时候，路由都不一定能获取到该参数
    watch: {
      // 如果路由有变化，会再次执行该方法
      '$route': 'getUserInfoFromCookie'
    },
```





### 19. nuxt 使用其他布局

https://nuxtjs.org/guide/views#layouts

Custom Layout

Every file (*top-level*) in the `layouts` directory will create a custom layout accessible with the `layout` property in the page components.

Let's say we want to create a blog layout and save it to `layouts/blog.vue`:

```html
<template>
  <div>
    <div>My blog navigation bar here</div>
    <nuxt />
  </div>
</template>
```

Then we have to tell the pages (i.e. `pages/posts.vue`) to use your custom layout:

```html
<template>
  <!-- Your template -->
</template>
<script>
  export default {
    /**
     * 指定布局，如果不写，则默认使用  layouts/default.vue 作为默认布局
     **/
    layout: 'blog'	
    // page component definitions
  }
</script>
```

More information about the `layout` property: [API Pages `layout`](https://nuxtjs.org/api/pages-layout)

Check out the [demonstration video](https://www.youtube.com/watch?v=YOKnSTp7d38) to see custom layouts in action.

其他页面跳转的时候直接使用 `<a>`标签即可，不用添加 `/pages`

```html
<a title="注册" href="/posts" target="_blank">
  <span class="vam ml5">注册</span>
</a>
```

### 20. elementUI 自带的表单验证

```html
<el-form-item class="input-prepend restyle" prop="nickname" :rules="[{ required: true, message: '请输入你的昵称', trigger: 'blur' }]">
  <div>
    <el-input type="text" placeholder="你的昵称" v-model="params.nickname"/>
    <i class="iconfont icon-user"/>
  </div>
</el-form-item>
<!--额外添加 {validator: checkPhone, trigger: 'blur'} 来添加自定义表单验证-->
<el-form-item class="input-prepend restyle no-radius" prop="mobile" :rules="[{ required: true, message: '请输入手机号码', trigger: 'blur' },{validator: checkPhone, trigger: 'blur'}]">
  <div>
    <el-input type="text" placeholder="手机号" v-model="params.mobile"/>
    <i class="iconfont icon-phone"/>
  </div>
</el-form-item>

<script>
	export default{
    methods:{
            checkPhone (rule, value, callback) {
        //debugger
        if (!(/^1[34578]\d{9}$/.test(value))) {
          return callback(new Error('手机号码格式不正确'))
        }
        return callback()
      }
    }
  }
</script>
```

### 21. 前端使用token登陆

https://www.npmjs.com/package/js-cookie

#### （1）安装

```shell
  $ npm install js-cookie --save
```

安装之后就可以直接使用了，但一定要使用import

`nuxt.config.js`

```javascript
  plugins: [
    '@/plugins/element-ui',
    { src: "~/plugins/nuxt-swiper-pluign.js", ssr: false },
    { src: "~/plugins/vue-qriously.js", ssr: false },
    { src: "~/plugins/js-cookie.js", ssr: false },	//添加
  ],
```

创建`plugins/js-cookie.js`

```javascript
import cookie from 'js-cookie'
import Vue from 'vue'
Vue.use(cookie)
```

导入并使用

```javascript
  import cookie from 'js-cookie'
export default{
  methods:{
      submitLogin() {
        login.login(this.user).then(resp=>{
          /**
           * {domain:'localhost'} 设置cookie的作用范围
           * 代表只要访问路径中含有 localhost 就都有效
           * */
          cookie.set('userToken',resp.data.token,{domain:'localhost'});

          console.log("登陆成功，并且已将token放入 cookie 中，token = ",cookie.get('userToken'));
        })
      }
  }
}
```



Create a cookie, valid across the entire site:

```
Cookies.set('name', 'value');
```

Create a cookie that expires 7 days from now, valid across the entire site:

```
Cookies.set('name', 'value', { expires: 7 });
```

Create an expiring cookie, valid to the path of the current page:

```
Cookies.set('name', 'value', { expires: 7, path: '' });
```

Read cookie:

```
Cookies.get('name'); // => 'value'
Cookies.get('nothing'); // => undefined
```

Read all visible cookies:

```
Cookies.get(); // => { name: 'value' }
```

The cookie with the name `foo` will only be available on `.get()` if it's visible from where the code is called; the domain and/or path attribute will not have an effect when reading.

Delete cookie:

```
Cookies.remove('name');
```

Delete a cookie valid to the path of the current page:

```
Cookies.set('name', 'value', { path: '' });
Cookies.remove('name'); // fail!
Cookies.remove('name', { path: '' }); // removed!
```

*IMPORTANT! When deleting a cookie and you're not relying on the [default attributes](https://www.npmjs.com/package/js-cookie#cookie-attributes), you must pass the exact same path and domain attributes that were used to set the cookie:*

```
Cookies.remove('name', { path: '', domain: '.yourdomain.com' });
```

存储json

js-cookie provides unobtrusive JSON storage for cookies.

When creating a cookie you can pass an Array or Object Literal instead of a string in the value. If you do so, js-cookie will store the string representation of the object according to `JSON.stringify`:

```
Cookies.set('name', { foo: 'bar' });
```

When reading a cookie with the default `Cookies.get` api, you receive the string representation stored in the cookie:

```
Cookies.get('name'); // => '{"foo":"bar"}'
Cookies.get(); // => { name: '{"foo":"bar"}' }
```

When reading a cookie with the `Cookies.getJSON` api, you receive the parsed representation of the string stored in the cookie according to `JSON.parse`:

```
Cookies.getJSON('name'); // => { foo: 'bar' }
Cookies.getJSON(); // => { name: { foo: 'bar' } }
```

#### （2）登陆步骤

【1】前端调用登陆`api`，`api`返回`token`

【2】把`token`通过`js-cookie`放入到`cookie`中

> 注意：cookie无法实现跨域（跨域名/ip读取）

````javascript
/**
           * {domain:'localhost'} 设置cookie的作用范围
           * 代表只要访问路径中含有 localhost 就都有效
           * */
cookie.set('userToken',resp.data.token,{domain:'localhost'});
````

【3】创建拦截器，判断`cookie`中是否有`token`，如果有，就把`token`放到`request`中的`header`中

```javascript
// request拦截器
service.interceptors.request.use(
  config => {

    let token = cookie.get('userToken');
    if (token) {
      console.log("cookie 中 含有 token，", token)
      /**
       * 把 cookie 中的 token 放到 request中的 header 中
       * */
      config.headers['token'] = token;
    }
    console.log("最终发送的请求是",config);
    // 一定要返回 config，否则请求不能被发送
    return config;
  },
  error => {
    // Do something with request error
    console.log(error) // for debug
  }
)
```



【4】根据`token`的值，调用接口，根据`token`获取用户信息，为了首页显示，将调用接口返回的用户信息放入到`cookie`中

```javascript
      async submitLogin() {
        let resp = await login.login(this.user);
        /**
         * {domain:'localhost'} 设置cookie的作用范围
         * 代表只要访问路径中含有 localhost 就都有效
         * */
        cookie.set('userToken', resp.data.token, {domain: 'localhost'});

        let token = cookie.get('userToken');

        console.log("登陆成功，并且已将token放入 cookie 中，token = ",token );

        /**
         * 根据 token 从后端获取用户信息
         * */
        let p = await login.getUserInfoByToken();

        console.log(p.data)

        cookie.set('userInfo',p.data.user,{domain:'localhost'});

        this.$message({
          message:'登陆成功',
          type:'success'
        });

        /**
         * 跳转主页
         * */
        this.$router.push('/');
      },
```



【5】在首页显示用户信息，从上一步获取用户信息

```javascript
    methods: {
      getUserInfoFromCookie() {
        this.userInfo = cookie.getJSON('userInfo');
        console.log("已登陆的用户信息是",this.userInfo);
      },
      exit(){
        this.userInfo = {};
        cookie.remove('userToken');
        cookie.remove('userInfo');
        console.log("已退出登陆");
        location.reload();
      }
    },
    created() {
      this.getUserInfoFromCookie();
    }
```

### 22. OAuth2

#### （1）主要解决

* 开放系统间授权

  按照特定的规则，生成字符串，把字符串颁发给访问者，访问者可以通过这个字符串访问服务

  需要考虑如何管理令牌，颁发令牌，吊销令牌，需要统一的协议，因此就有了`Oauth2`协议

* 分布式访问问题

#### （2）步骤

1. 登陆成功之后，按照一定的规则生成字符串，字符串包含用户信息
2. 把字符串通过路径进行传递，或者放在`cookie`中
3. 后面再次发送请求的时候，都是带着`token`字符串进行发送，获取字符串，从字符串获取用户信息登陆

#### （3）oauth2解决方案

令牌机制：按照一定的规则生成字符串，字符串包含用户信息

### 23. 正确的解析 json 中的属性的方式

```java
/**
         * 第三步：
         * 拿着第二步获取到的两个值（access_token,openid）再去请求一个微信提供的固定地址，最终才可以获取到微信扫码人的信息
         * 微信昵称，微信头像
         *
         * 第二步返回的结果：
         * {
         *     "access_token":"36_MgzegOKv83EitvB7gqaeUdMNrsuXY6mpHARoTBI2U_MIM3dHoCpV30SVu2mgLiip8IFGCYMXHWhNnRPyngp2ts9uKuz_TpCfRijhrLPpli0",
         *     "expires_in":7200,
         *     "refresh_token":"36_NVEkoPXI5Jo26vnIW3cm7CsILSISU_Yi9Uf58JDfiSNG2VrUhSZVJAyV9qUugjHkI5RFP_VEJl4H9Vk53qNXusQuYGF8Nzwr2KA2J-3SjkU",
         *     "openid":"o3_SC56hygMpCfh5HmIFQuRY_hb4",
         *     "scope":"snsapi_login",
         *     "unionid":"oWgGz1NayVWhauyeGVUeGXzs2N-s"
         * }
         * 需要读取其中的(access_token,openid)，
         * 比较简单的办法是把 上面的json转换为map集合，根据map里面的key获取对应的值
         * */
        HashMap<String, String> map = new HashMap<>();

        try {
            Map readValueMap = new ObjectMapper().readValue(resultOfStep2, Map.class);

            String accessToken = readValueMap.get("access_token").toString();
            String openid = readValueMap.get("openid").toString();

            log.info("通过jackson解析到的 accessToken = " + accessToken + "，openid = " + openid);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
```

### 24. 在同一service下的方法A调用方法B，给方法B添加通知

默认情况下： 同一service中的方法互调，不能触发aop的通知

解决方法：注入 IOC 容器到该service，再通过IOC获取该服务本身就能调用和该方法处于同一类的方法，并且还带有 通知方法

> 注意：通知类，即`@Aspect` 和`@Component`注解所修饰的类，不能直接写在本`service`中，要单独开辟一个类
>
> 环绕通知只能传入`ProceedingJoinPoint`对象，不可以多传任何参数，否则运行报错，切点方法所执行的参数和返回的结果都要通过`ProceedingJoinPoint`对象来获取

### 25. nuxt 专有的 asyncData

https://zh.nuxtjs.org/api/

#### （1）asyncData 方法

> 你可能想要在服务器端获取并渲染数据。Nuxt.js 添加了`asyncData`方法使得你能够在渲染组件之前异步获取数据。

类型： `Function`

`asyncData`方法会在组件（**限于页面组件**）每次加载之前被调用。它可以在服务端或路由更新之前被调用。在这个方法被调用的时候，第一个参数被设定为当前页面的**上下文对象**，你可以利用 `asyncData`方法来获取数据并返回给当前组件。

```js
export default {
  data() {
    return { project: 'default' }
  },
  asyncData(context) {
    return { project: 'nuxt' }
  }
}
```

注意：由于`asyncData`方法是在组件 **初始化** 前被调用的，所以在方法内是没有办法通过 `this` 来引用组件的实例对象。

### 26. 阿里云网页视频播放器

#### （1）不加密，html播放器

[在线配置地址](https://player.alicdn.com/aliplayer/setting/setting.html?spm=a2c4g.11186623.2.17.7e296782Rjae7Z)

[官方文档](https://help.aliyun.com/document_detail/125548.html?spm=a2c4g.11186623.6.1089.5fb81c4cm0zDOE)

手动在网页配置

![Snip20200901_1](/Users/luo/Documents/开发笔记/images/Snip20200901_1.png)

复制生成的代码

![Snip20200901_2](/Users/luo/Documents/开发笔记/images/Snip20200901_2.png)

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/>
  <title>Aliplayer Online Settings</title>
  <link rel="stylesheet" href="https://g.alicdn.com/de/prismplayer/2.8.8/skins/default/aliplayer-min.css"/>
  <script type="text/javascript" charset="utf-8"
          src="https://g.alicdn.com/de/prismplayer/2.8.8/aliplayer-min.js"></script>
</head>
<body>
<div class="prism-player" id="player-con"></div>
<script>
  var player = new Aliplayer({
      "id": "player-con",
      // 视屏地址
      "source": "https://outin-8b89ea44e4e011eaabb800163e1a65b6.oss-cn-shanghai.aliyuncs.com/sv/4f240554-1742eb3900c/4f240554-1742eb3900c.mp4?Expires=1598925082&OSSAccessKeyId=LTAIxSaOfEzCnBOj&Signature=Pdt50j138FoRwyWwLwvb82kbsQk%3D",
      "width": "100%",
      "height": "500px",
      "autoplay": true,
      "isLive": false,
      // 视屏封面地址
      "cover": "https://guli-998.oss-cn-beijing.aliyuncs.com/courseCover/2020/08/19/0787d64d20b946dfafa04fb9e8cd16d2-151911.jpg",
      "rePlay": false,
      "playsinline": true,
      "preload": true,
      "controlBarVisibility": "hover",
      "useH5Prism": true
    }, function (player) {
      console.log("The player is created");
    }
  );
</script>
</body>
```

#### （2）使用视频凭证进行播放

获取视频的授权

```java

    /*获取播放凭证函数*/
    public static GetVideoPlayAuthResponse getVideoPlayAuth(DefaultAcsClient client) throws Exception {
        GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();
        /**
         * 设置视频id
         * */
        request.setVideoId("7e65222741cf48f382c4ded571d99ac5");
        return client.getAcsResponse(request);
    }
    /*以下为调用示例*/
    @Test
    void getVideoAuthByVideoId() {
        DefaultAcsClient client = PlayVideoByVideoId.initVodClient(OssProperties.ACCESS_KEY_ID, OssProperties.ACCESS_KEY_SECRET);
        GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse();
        try {
            response = getVideoPlayAuth(client);
            //播放凭证
            System.out.print("PlayAuth = " + response.getPlayAuth() + "\n");
            //VideoMeta信息
            System.out.print("VideoMeta.Title = " + response.getVideoMeta().getTitle() + "\n");
        } catch (Exception e) {
            System.out.print("ErrorMessage = " + e.getLocalizedMessage());
        }
        System.out.print("RequestId = " + response.getRequestId() + "\n");
    }
```

写入视频id 和 视频授权到阿里云播放器中

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/>
  <title>Aliplayer Online Settings</title>
  <link rel="stylesheet" href="https://g.alicdn.com/de/prismplayer/2.8.8/skins/default/aliplayer-min.css"/>
  <script type="text/javascript" charset="utf-8"
          src="https://g.alicdn.com/de/prismplayer/2.8.8/aliplayer-min.js"></script>
</head>
<body>
<div class="prism-player" id="player-con"></div>
<h2>播放加密的阿里云视频</h2>
<script>
  var player = new Aliplayer({
      "id": "player-con",
      // 视屏地址，要通过视频id和视频授权码来播放，所以这里的视频地址就没有意义了
      //"source": "https://outin-8b89ea44e4e011eaabb800163e1a65b6.oss-cn-shanghai.aliyuncs.com/sv/4f240554-1742eb3900c/4f240554-1742eb3900c.mp4?Expires=1598925082&OSSAccessKeyId=LTAIxSaOfEzCnBOj&Signature=Pdt50j138FoRwyWwLwvb82kbsQk%3D",

      // 根据视频凭证进行播放器的设置
      encryptType: '0', //如果播放的视频加密，则需要设置encryptType:'1'，非加密视频则无需配置这项
      vid:'7e65222741cf48f382c4ded571d99ac5', //要播放的视频id
      // 该视频的授权码，通过后端sdk获取，注意拼写，全小写 playauth
  	playauth:'eyJTZWN1cml0eVRva2VuIjoiQ0FJUzN3SjFxNkZ0NUIyeWZTaklyNWJVZU0zZTJPWVg4Nit6U2tYeXRYWm1YZDFLaHBIK216ejJJSGhKZVhOdkJPMGV0ZjQrbVdCWTdQY1lsck1xRzhjYUZSMlpOWklzdjhzTHFGendKcExGc3QySjZyOEpqc1V3bjVwQXAxaXBzdlhKYXNEVkVma3VFNVhFTWlJNS8wMGU2TC8rY2lyWVhEN0JHSmFWaUpsaFE4MEtWdzJqRjFSdkQ4dFhJUTBRazYxOUszemRaOW1nTGlidWkzdnhDa1J2MkhCaWptOHR4cW1qL015UTV4MzFpMXYweStCM3dZSHRPY3FjYThCOU1ZMVdUc3Uxdm9oemFyR1Q2Q3BaK2psTStxQVU2cWxZNG1YcnM5cUhFa0ZOd0JpWFNaMjJsT2RpTndoa2ZLTTNOcmRacGZ6bjc1MUN0L2ZVaXA3OHhtUW1YNGdYY1Z5R0dOLzZuNU9aUXJ6emI0WmhKZWVsQVJtWGpJRFRiS3VTbWhnL2ZIY1dPRGxOZjljY01YSnFBWFF1TUdxQ2QvTDlwdzJYT2x6NUd2WFZnUHRuaTRBSjVsSHA3TWVNR1YrRGVMeVF5aDBFSWFVN2EwNDQvNWVUWWFwazFNVWFnQUVrUnd1dlZrQVd1aFZ2azI5ZUR5dmcrNnRLbm05NjZrMVR2MkFWbnhsU2k1TjFFZm1QTVpaVWJ1RktMM3VMdDQ4R1Y3Uk5BYU9yaGtJTmJYTEo5TjYxK2M1akZnR2pza1dudUR2a0pDUEtTeDhISFlEaXdJdXM3QmQwUUZ5NUJnY1RHVmJCYmRhS3hLV2l1ZXI3eXJJRTk0ZTZtaGc3WXFKRTNjeGdWMk9OR1E9PSIsIkF1dGhJbmZvIjoie1wiQ0lcIjpcInYyYm9EMmt2S1lHcEtEM3poRkdidUVCYytEbDJGZ0cwMFpzYkYrT3lsc2Q2ZG1EL2xEcEhJYks2WElIdlJjV0VcXHJcXG5cIixcIkNhbGxlclwiOlwiNmxzeEQ4Rkh3Q3YvZHlQVCtieHdHREk0dDhQTW4vZ2VVMnh3MUJWZ3ZqST1cXHJcXG5cIixcIkV4cGlyZVRpbWVcIjpcIjIwMjAtMDktMDFUMDE6MTM6MjVaXCIsXCJNZWRpYUlkXCI6XCI3ZTY1MjIyNzQxY2Y0OGYzODJjNGRlZDU3MWQ5OWFjNVwiLFwiU2lnbmF0dXJlXCI6XCJkK3JjSkxxWTlvUTZLM0xZaUtUaURic2ZlckU9XCJ9IiwiVmlkZW9NZXRhIjp7IlN0YXR1cyI6Ik5vcm1hbCIsIlZpZGVvSWQiOiI3ZTY1MjIyNzQxY2Y0OGYzODJjNGRlZDU3MWQ5OWFjNSIsIlRpdGxlIjoi5qGM6Z2i5b2V5Yi2IiwiQ292ZXJVUkwiOiJodHRwOi8vb3V0aW4tOGI4OWVhNDRlNGUwMTFlYWFiYjgwMDE2M2UxYTY1YjYub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS83ZTY1MjIyNzQxY2Y0OGYzODJjNGRlZDU3MWQ5OWFjNS9zbmFwc2hvdHMvN2JmOGYzODg1NmZlNDBiN2E2YjU1YmQzMDA3MjhmZTAtMDAwMDEuanBnP0V4cGlyZXM9MTU5ODkyNjMwNSZPU1NBY2Nlc3NLZXlJZD1MVEFJeFNhT2ZFekNuQk9qJlNpZ25hdHVyZT0yVWp6UXhKaVZHRlZNQVdWdFFUNEpNZE8lMkZuWSUzRCIsIkR1cmF0aW9uIjo2Ljk2N30sIkFjY2Vzc0tleUlkIjoiU1RTLk5VYTN3ajU5NkRtWEhjQ1F2M1FSZmlUVXkiLCJBY2Nlc3NLZXlTZWNyZXQiOiI5Smk1N3B2ZHI0aHRkaVd2aHFFcTFXN2FhaFBaRVF3aFNqdWc0dDlkU0xpciIsIlJlZ2lvbiI6ImNuLXNoYW5naGFpIiwiQ3VzdG9tZXJJZCI6MTgwNzg5NTAxNDk3NDE3OX0',


      "width": "100%",
      "height": "500px",
      "autoplay": true,
      "isLive": false,
      // 视屏封面地址
      "cover": "https://guli-998.oss-cn-beijing.aliyuncs.com/courseCover/2020/08/19/0787d64d20b946dfafa04fb9e8cd16d2-151911.jpg",
      "rePlay": false,
      "playsinline": true,
      "preload": true,
      "controlBarVisibility": "hover",
      "useH5Prism": true
    }, function (player) {
      console.log("The player is created");
    }
  );
</script>
</body>

```

### 27. 微信支付

https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Pay/WP.html

#### （1）导入HttpClient依赖

```xml
<!-- http 请求客户端 -->
<dependency>
  <groupId>org.apache.httpcomponents</groupId>
  <artifactId>httpclient</artifactId>
</dependency>

<!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore -->
<dependency>
  <groupId>org.apache.httpcomponents</groupId>
  <artifactId>httpcore</artifactId>
</dependency>
```

#### （2）用到的https工具类

```java
package com.guli.utils;

import org.apache.http.Consts;
import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.*;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * https请求客户端
 * 用于发送Https请求
 * @author qy
 * 
 */
public class HttpClient {
	private String url;
	private Map<String, String> param;
	private int statusCode;
	private String content;
	private String xmlParam;
	private boolean isHttps;

	public boolean isHttps() {
		return isHttps;
	}

	public void setHttps(boolean isHttps) {
		this.isHttps = isHttps;
	}

	public String getXmlParam() {
		return xmlParam;
	}

	public void setXmlParam(String xmlParam) {
		this.xmlParam = xmlParam;
	}

	public HttpClient(String url, Map<String, String> param) {
		this.url = url;
		this.param = param;
	}

	public HttpClient(String url) {
		this.url = url;
	}

	public void setParameter(Map<String, String> map) {
		param = map;
	}

	public void addParameter(String key, String value) {
		if (param == null)
			param = new HashMap<String, String>();
		param.put(key, value);
	}

	public void post() throws ClientProtocolException, IOException {
		HttpPost http = new HttpPost(url);
		setEntity(http);
		execute(http);
	}

	public void put() throws ClientProtocolException, IOException {
		HttpPut http = new HttpPut(url);
		setEntity(http);
		execute(http);
	}

	public void get() throws ClientProtocolException, IOException {
		if (param != null) {
			StringBuilder url = new StringBuilder(this.url);
			boolean isFirst = true;
			for (String key : param.keySet()) {
				if (isFirst)
					url.append("?");
				else
					url.append("&");
				url.append(key).append("=").append(param.get(key));
			}
			this.url = url.toString();
		}
		HttpGet http = new HttpGet(url);
		execute(http);
	}

	/**
	 * set http post,put param
	 */
	private void setEntity(HttpEntityEnclosingRequestBase http) {
		if (param != null) {
			List<NameValuePair> nvps = new LinkedList<NameValuePair>();
			for (String key : param.keySet())
				nvps.add(new BasicNameValuePair(key, param.get(key))); // 参数
			http.setEntity(new UrlEncodedFormEntity(nvps, Consts.UTF_8)); // 设置参数
		}
		if (xmlParam != null) {
			http.setEntity(new StringEntity(xmlParam, Consts.UTF_8));
		}
	}

	private void execute(HttpUriRequest http) throws ClientProtocolException,
			IOException {
		CloseableHttpClient httpClient = null;
		try {
			if (isHttps) {
				SSLContext sslContext = new SSLContextBuilder()
						.loadTrustMaterial(null, new TrustStrategy() {
							// 信任所有
							public boolean isTrusted(X509Certificate[] chain,
									String authType)
									throws CertificateException {
								return true;
							}
						}).build();
				SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
						sslContext);
				httpClient = HttpClients.custom().setSSLSocketFactory(sslsf)
						.build();
			} else {
				httpClient = HttpClients.createDefault();
			}
			CloseableHttpResponse response = httpClient.execute(http);
			try {
				if (response != null) {
					if (response.getStatusLine() != null)
						statusCode = response.getStatusLine().getStatusCode();
					HttpEntity entity = response.getEntity();
					// 响应内容
					content = EntityUtils.toString(entity, Consts.UTF_8);
				}
			} finally {
				response.close();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			httpClient.close();
		}
	}

	public int getStatusCode() {
		return statusCode;
	}

	public String getContent() throws ParseException, IOException {
		return content;
	}

}

```

#### （3）获取微信支付二维码地址的方法

```java
 public Map<String, String> generate2DimensionalityCodeAddress(String orderNo) {
        try {
            //1.根据订单号查询订单信息
            Order order = orderService.getOrderByOrderNo(orderNo);

            //2.使用map设置生成二维码所需要的参数
            Map<String, String> map = new LinkedHashMap<>();
            map.put("appid", WeChatPaymentProperties.APP_ID);    // 微信id
            map.put("mch_id", WeChatPaymentProperties.PARTNER); // 商户号
            map.put("nonce_str", WXPayUtil.generateNonceStr()); // 使用微信自带的工具生成随机码
            map.put("body", order.getCourseTitle()); //支付二维码显示的名称，这里显示课程标题
            map.put("out_trade_no", orderNo); //订单号作为唯一标识
            map.put("total_fee", order.getTotalFee().multiply(new BigDecimal("100")).longValue() + "");
            map.put("spbill_create_ip", "127.0.0.1"); // 进行支付的地址，服务器地址（可以写域名）
            //map.put("notify_url", "http://guli.shop/api/order/weixinPay/weixinNotify\n"); // 回调地址，注意换行
            map.put("notify_url", WeChatPaymentProperties.NOTIFY_URL);
            map.put("trade_type", "NATIVE"); // 支付类型，native代表根据价格生成二维码

            //3.发送HttpClient请求，传递参数xml格式，微信支付提供固定的地址
            //用商户key将map中的数据进行加密
            String orderInfo = WXPayUtil.generateSignedXml(map, WeChatPaymentProperties.PARTNER_KEY);
            // 因为地址是固定的，所以可以写死
            HttpClient httpClient = new HttpClient("https://api.mch.weixin.qq.com/pay/unifiedorder");
            httpClient.setXmlParam(orderInfo);
            httpClient.setHttps(true);
            httpClient.post(); // 发送post请求

            //4.得到第一次微信支付响应结果
            // 返回的内容是xml格式的
            String xmlContent = httpClient.getContent();

            //把xml格式转换map集合，把map集合返回
            Map<String, String> resultMap = WXPayUtil.xmlToMap(xmlContent);

            //最终返回数据 的封装
            Map<String, String> map2 = new HashMap<>();
            map2.put("out_trade_no", orderNo);
            map2.put("course_id", order.getCourseId());
            map2.put("total_fee", order.getTotalFee().toString());
            map2.put("result_code", resultMap.get("result_code"));  //返回二维码操作状态码
            map2.put("code_url", resultMap.get("code_url"));        //二维码地址
            return map2;
        } catch (Exception e) {
            throw new CustomizedException(40001,"生成微信支付二维码异常");
        }
    }

```

#### （4）查询微信支付的状态

```java
public Map<String, String> queryPaymentStatus(String orderNo) {

        //1. 封装请求参数
        Map<String, String> map = new LinkedHashMap<>();

        map.put("appid", WeChatPaymentProperties.APP_ID);
        map.put("mch_id", WeChatPaymentProperties.PARTNER);
        map.put("out_trade_no", orderNo);   // 要查询的订单号
        map.put("nonce_str", WXPayUtil.generateNonceStr());


        try {
            //2.发送http请求查询支付情况
            // 固定地址，可以写死
            HttpClient http = new HttpClient("https://api.mch.weixin.qq.com/pay/orderquery");

            String queryParamsXml = WXPayUtil.generateSignedXml(map, WeChatPaymentProperties.PARTNER_KEY);

            http.setXmlParam(queryParamsXml);
            http.setHttps(true);
            http.post();

            //3.得到httpClient的响应
            String xmlContent = http.getContent();

            Map<String, String> resultMap = WXPayUtil.xmlToMap(xmlContent);

            return resultMap;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }
```

#### （5）前端显示微信支付二维码

vue中下载微信支付二维码的一个组件

[官网](https://www.npmjs.com/package/vue-qriously) （不再维护）

```shell
npm install vue-qriously
```

安装

```javascript
// ES6
import Vue from 'vue'
import VueQriously from 'vue-qriously'
Vue.use(VueQriously)
```

使用

```html
<qriously value="Hello World!" :size="200" />
```

1. 注册微信开发者资质（只支持企业类型）
2. 注册之后有微信id 和微信密钥
3. 准备营业执照，1-2个工作日，300元
4. 申请网站应用名称
5. 需要域名地址（扫描二维码之后跳转的域名）



### 28. sql中的日期条件查询

#### （1）方法一、只取出表中列的日期，忽略时间

```sql
-- 使用 Date() 函数将列转换为日期
select count(*) from ucenter_member 
where DATE(gmt_create) > '2010-1-1'
```

#### （2）方法二、将字符串转换为日期，再与表中的列日期做比较

> 1.mysql日期和字符相互转换方法 
> date_format(date,’%Y-%m-%d’) ————–>oracle中的to_char(); 
> str_to_date(date,’%Y-%m-%d’) ————–>oracle中的to_date();
>
> %Y：代表4位的年份 
> %y：代表2为的年份
>
> %m：代表月, 格式为(01……12) 
> %c：代表月, 格式为(1……12)
>
> %d：代表月份中的天数,格式为(00……31) 
> %e：代表月份中的天数, 格式为(0……31)
>
> %H：代表小时,格式为(00……23) 
> %k：代表 小时,格式为(0……23) 
> %h： 代表小时,格式为(01……12) 
> %I： 代表小时,格式为(01……12) 
> %l ：代表小时,格式为(1……12)
>
> %i： 代表分钟, 格式为(00……59) 【只有这一个代表分钟，大写的I 不代表分钟代表小时】
>
> %r：代表 时间,格式为12 小时(hh:mm:ss [AP]M) 
> %T：代表 时间,格式为24 小时(hh:mm:ss)
>
> %S：代表 秒,格式为(00……59) 
> %s：代表 秒,格式为(00……59)
>
> 2.例子： 
>
> ```sql
> select str_to_date(‘09/01/2009’,’%m/%d/%Y’)
> 
> select str_to_date(‘20140422154706’,’%Y%m%d%H%i%s’)
> 
> select str_to_date(‘2014-04-22 15:47:06’,’%Y-%m-%d %H:%i:%s’)
> ```

```sql


select count(*) from ucenter_member 
where gmt_create > STR_TO_DATE('2010-10-10','%Y-%m-%d')
```

#### （3）方法三、使用mybatis-plus自动将Date对象做等值比较

```java
    public Long getRegisteredUserNumberOfaDay(Date date) {

        QueryWrapper<UcenterMember> memberQueryWrapper = new QueryWrapper<>();

        /**
         * 因为  java.sql.Date 只包含日期，不包含时间，所以可以过滤时间，用于日期等值查询
         * */
        java.sql.Date sqlDate = new java.sql.Date(date.getTime());

        /**
         * 不能这样做，因为列中不仅有日期，还有时间，而查询的只有日期，所以无法等值查询
         * memberQueryWrapper.eq("gmt_create", sqlDate);
         *
         * 也不能这样，因为，mybatis-plus 将 is_deleted 做了自动填充，会多了一个where
         * memberQueryWrapper.last("where Date(gmt_create) = "+sqlDate);
         * SELECT COUNT( 1 ) FROM ucenter_member   WHERE  is_deleted=0     where Date(gmt_create) = 2020-09-03
         *
         * 错误，2020-09-03 需要带上''才能识别，添加 sqlDate.toString()，无效
         * memberQueryWrapper.last("and Date(gmt_create) = "+sqlDate);
         * SELECT COUNT( 1 ) FROM ucenter_member WHERE is_deleted=0 and Date(gmt_create) = 2020-09-03
         *
         * 正常可查询
         * memberQueryWrapper.last("and Date(gmt_create) = '" + sqlDate.toString()+"'");
         * SELECT COUNT( 1 ) FROM ucenter_member WHERE is_deleted=0 and Date(gmt_create) = '2020-09-03'
         * */
        memberQueryWrapper.last("and Date(gmt_create) = '" + sqlDate.toString()+"'");


        int count = this.count(memberQueryWrapper);

        return new Long(count);

    }
```

### 29.定时任务

#### （1）开启

`@EnableScheduling`

```java
@SpringBootApplication
@EnableFeignClients
@MapperScan(basePackages = "com.guli.statistic.mapper")
@EnableScheduling
public class StatisticApp {

    public static void main(String[] args) {
        SpringApplication.run(StatisticApp.class,args);
    }

}
```

#### （2）创建定时任务类

在这个类中使用表达式来设置什么时候执行

cron表达式设置执行的规则

cron表达式又称为，七子表达式，七域表达式

[在线生成表达式](https://cron.qqe2.com/)

https://www.pppet.net/

https://www.beejson.com/tool/cron.html

```java
@Component
@Slf4j
public class StatisticSchedule {

    @Resource
    StatisticsDailyService statisticsDailyService;

    /**
     * cron = "0/5 * * * * ?" 代表每隔5秒钟执行一次这个方法
     * cron 表达式有7位，但是springboot只支持6位，
     * cron表达式的最后一位是年，springboot中默认表示当前这年
     * ? 表示任意
     */
    @Scheduled(cron = "0/5 * * * * ?")
    public void scheduleTask1() {
        System.out.println("定时任务1执行了");
    }


    @Scheduled()
    public void statisticData() {
        Date date = new Date();

        java.sql.Date sqlDate = new java.sql.Date(date.getTime() - 1000 * 60 * 60 * 24);

        log.info(sqlDate + "执行统计");

        statisticsDailyService.executeStatistic(sqlDate);
    }

}

```

### 30. Echarts

安装

```shell
npm install echarts --save
```

使用

```html
<template>
  <div>
    <div id="main"></div>
  </div>
</template>

<script>
  var echarts = require('echarts');

  export default {
    name: "index",
    methods:{
      draw(){
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('main'));

        // 绘制图表
        myChart.setOption({
          title: {
            text: 'ECharts 入门示例'
          },
          tooltip: {},
          xAxis: {
            data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
          },
          yAxis: {},
          series: [{
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
          }]
        });
      }
    }
  }
</script>
```



### 31. 数据库数据同步

`Canal`的原理是基于`mysql`的`binlong`技术，所以需要开启`mysql`的`binlog`写入功能

创建`mysql`容器

```shell
luo@luodeMacBook-Pro ~ % docker run -d --name mysql-cancal -v /Volumes/extend/docker_public_file_mapping/cancal/mysql/my.cnf:/etc/mysql/my.cnf -p 12345:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
# 这样会导致，my.cnf 为全局可读写，mysql会忽略这个文件
2020-09-05 23:23:53+00:00 [Note] [Entrypoint]: Temporary server started.
mysql: [Warning] World-writable config file '/etc/mysql/my.cnf' is ignored.

# 这样可以使得my.cnf在物理机上可读写，在容器中只读
luo@luodeMacBook-Pro ~ % docker run -d --name mysql-cancal -v /Volumes/extend/docker_public_file_mapping/cancal/mysql/my.cnf:/etc/mysql/my.cnf:ro -p 12345:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
# 但是在容器上依然显示可读可写可执行，实际上只读
lrwxrwxrwx 1 root root   24 Aug  4 23:20 my.cnf -> /etc/alternatives/my.cnf
root@5ffd0548c35a:/etc/mysql# chmod 711 my.cnf
chmod: changing permissions of 'my.cnf': Read-only file system

#最终版本（只有mysql）
luo@luodeMacBook-Pro ~ % docker run -d --name canal -v /Volumes/extend/docker_public_file_mapping/cancal/mysql/my.cnf:/opt/my.cnf -p 12345:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
# 先映射，然后手动复制到/etc/mysql/my.cnf
# 注意要有 [mysqld]
```

#### （1）准备docker环境

使用`DockerFile`安装`mysql+java+canal`（推荐）

```dockerfile
FROM mysql:5.7
MAINTAINER luo<1007052116@qq.com>

# 把 java与tomcat添加到容器中（ADD命令自带解压功能）
ADD jdk-8u251-linux-x64.tar.gz /usr/local/
ADD canal.deployer-1.1.4.tar.gz /opt/canal/

COPY my.cnf /etc/mysql

# 修改 my.cnf 的权限，如果全局可写，mysql将会忽略这个文件中的配置
RUN ["/bin/bash","-c","chmod 744 /etc/mysql/my.cnf"]

# 设置工作访问的时候WORKDIR路径，登陆后的落脚点
ENV myPath /opt/canal/bin
WORKDIR $myPath

# 配置java 与tomcat的环境变量
ENV JAVA_HOME /usr/local/jdk1.8.0_251/
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

ENV PATH $PATH:$JAVA_HOME/bin

# 容器运行时监听的端口
EXPOSE 3306 11111

# 启动时运行mysql，可以不写，因为是继承 mysql:5.7，其启动命令也被继承了
# CMD ["mysqld"]

```

通过`DockerFile`构建镜像

```shell
luo@luodeMacBook-Pro cancal % docker build -f /Volumes/OS/javaEE/jar/cancal/DockerFile  -t canal ./
```

运行通过`DockerFile`构建出来的镜像

```shell
# -v 映射 my.cnf 文件可以省略
luo@luodeMacBook-Pro cancal % docker run -d --name canal  -v /Volumes/extend/docker_public_file_mapping/cancal/mysql/my.cnf:/opt/my.cnf -p 12345:3306 -p 11111:11111 -e MYSQL_ROOT_PASSWORD=123456 canal
```

#### （2）查看数据库的`log_bin`功能是否开启

```sql
show variables like 'log_bin'
```

如果未开启，则需要修改`/etc/mysql/my.cnf`文件，添加以下，不是`/etc/mysql/mysql.cnf`

```shell
[mysqld]
# binlog文件名
log-bin=mysql-bin 

# 选择row模式
binlog_format=ROW

# mysql实例id，注意不能和cancal的slaveId重复
server_id=1
```

#### （3）安装`cancal`

https://github.com/alibaba/canal

#### （4）修改 canal 的配置文件

配置`canal`连接`mysql`，并同步`mysql`

修改`conf/example/instance.properties`，这个文件在物理机上，可以解压 `canal.tar.gz`得到

```properties
# position info 修改数据库所在地址
canal.instance.master.address=127.0.0.1:3306

# username/password 改成数据库的账号密码
canal.instance.dbUsername=root
canal.instance.dbPassword=123456

# table regex     指定表的正则匹配规则，匹配到的表更新之后，该表会被同步
# 转义字符需要使用 \\ 双斜杠，       \\. 代表 .
# .*\\..* 匹配所有库中的所有表
#canal.instance.filter.regex=.*\\..* 

# 只同步 guli 数据库下的 ucenter_member 表
canal.instance.filter.regex=guli.ucenter_member

# guli 下 以 edu 开头的表
canal.instance.filter.regex=guli\\.edu.*

# guli 下 所有的表
canal.instance.filter.regex=guli\\..*

# 多个规则组合使用，使用逗号分隔
canal.instance.filter.regex=guli\\..*,home.test1,home.test2
# 注意：此过滤条件只针对row 模式的数据有效
# mixed/statement 因为不解析sql，所以无法准确提取 tableName 进行过滤
```

将修改好的`conf/example/instance.properties`上传到容器

```shell
luo@luodeMacBook-Pro cancal % docker cp /Volumes/OS/javaEE/jar/cancal/canal.deployer-1.1.4/conf/example/instance.properties  canal:/opt/canal/conf/example/
```

#### （5）添加依赖

```xml
<!--
        canal 客户端依赖
-->
        <dependency>
            <groupId>com.alibaba.otter</groupId>
            <artifactId>canal.client</artifactId>
        </dependency>

        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <dependency>
            <groupId>commons-dbutils</groupId>
            <artifactId>commons-dbutils</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

```

#### （6）具体代码看 canal-client-edu模块

代码只能同步表中全是字符串的的数据，如果含有`integer`，则他会在数字前后拼接""即`'998'`，导致无法插入数据

### 32. gateway

#### （1）跨域问题

跨域问题要么在`gateway`中解决跨域，要么在微服务中使用`@CrossOrigin`，两者不能同时使用

#### （2）gateway配置跨域

```java
@Bean
    public CorsWebFilter corsWebFilter(){
        /**
         * 注意因为gateway底层使用webflix响应式编程，所以需要使用
         * org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource
         * 不要导错包
         * */
        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();

        CorsConfiguration corsConfiguration = new CorsConfiguration();

        // 允许哪些请求头跨域
        corsConfiguration.addAllowedHeader("*");

        // 允许哪些请求方式可以跨域,get,post,put,delete
        corsConfiguration.addAllowedMethod("*");

        //允许什么请求来源进行跨域
        corsConfiguration.addAllowedOrigin("*");

        // 允许携带cookie进行跨域，不开启，跨域的时候就会丢失cookie信息
        corsConfiguration.setAllowCredentials(true);

        /**
         * 设置任意路径都需要进行跨域
         * */
        corsConfigurationSource.registerCorsConfiguration("/**",corsConfiguration);

        CorsWebFilter corsWebFilter = new CorsWebFilter(corsConfigurationSource);
        return corsWebFilter;
    }
```

#### （3）微服务自身开启跨域配置

网关和微服务职能开启一个跨域配置

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("*")
            .allowCredentials(true)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .maxAge(3600);
    }
}
```



### 33. spring security

如果系统模块众多，每个模块都需要进行认证与授权，所以我们选择基于`token`形式的授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为`key`，权限列表为value的形式存入`redis`缓存中，根据用户名相关信息生成`token`返回给浏览器，浏览器将`token`记录到`cookie`中，每次浏览器调用`api`接口都默认将`token`携带到请求头`header`中，`spring security`解析`header`请求头，获取`token`信息，再解析`token`获取当前访问的用户名，再根据用户名就可以从`redis`中获取权限列表，这样`spring security`就可以判断当前请求是否有权限访问

![01 Spring Security授权过程](/Users/luo/Documents/开发笔记/images/01 Spring Security授权过程.png)